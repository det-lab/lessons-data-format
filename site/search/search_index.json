{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Creating a custom data format Created by Adrian Fisher Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. setup.md # Setting up kaitai and construct filetype.md # Describing file formats and types kaitai_basics.md # Describing the basics of using Kaitai construct_basics.md # Describing the basics of using Construct putting_it_together.md # Creating fake data and learning to compile it conclusion.md # Conclusion (TODO) advanced.md # Section for advanced users ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#creating-a-custom-data-format","text":"Created by Adrian Fisher","title":"Creating a custom data format"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. setup.md # Setting up kaitai and construct filetype.md # Describing file formats and types kaitai_basics.md # Describing the basics of using Kaitai construct_basics.md # Describing the basics of using Construct putting_it_together.md # Creating fake data and learning to compile it conclusion.md # Conclusion (TODO) advanced.md # Section for advanced users ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"advanced/","text":"i: Advanced Advanced Kaitai Users There are several reasons that one might choose to install the Kaitai-Struct-Compiler directly onto their machines as opposed to using the Web IDE. The desktop and console versions can also be used when you're done using the Web IDE to compile the file for other programming languages. The different OS downloads are available here . After installation, you should have: * ksc ( kaitai-struct-compiler ) - a command line Kaitai Struct Compiler which translates .ksy files into parsing libraries for a chosen target language. * ksv ( kaitai-struct-visualizer , optional) a console visualizer Advanced Construct Users While not necessary for this lesson, if you instead wish to install all the supported modules alongside your Construct install, instead type or copy the following and hit enter: pip install construct[extras]","title":"Advanced"},{"location":"advanced/#i-advanced","text":"","title":"i: Advanced"},{"location":"advanced/#advanced-kaitai-users","text":"There are several reasons that one might choose to install the Kaitai-Struct-Compiler directly onto their machines as opposed to using the Web IDE. The desktop and console versions can also be used when you're done using the Web IDE to compile the file for other programming languages. The different OS downloads are available here . After installation, you should have: * ksc ( kaitai-struct-compiler ) - a command line Kaitai Struct Compiler which translates .ksy files into parsing libraries for a chosen target language. * ksv ( kaitai-struct-visualizer , optional) a console visualizer","title":"Advanced Kaitai Users"},{"location":"advanced/#advanced-construct-users","text":"While not necessary for this lesson, if you instead wish to install all the supported modules alongside your Construct install, instead type or copy the following and hit enter: pip install construct[extras]","title":"Advanced Construct Users"},{"location":"conclusion/","text":"7: Conclusion TODO Include YT community dev mailing list (yt-dev@python.org), Professor Roberts' email, kaitai gitter link","title":"Conclusion"},{"location":"conclusion/#7-conclusion","text":"TODO Include YT community dev mailing list (yt-dev@python.org), Professor Roberts' email, kaitai gitter link","title":"7: Conclusion"},{"location":"construct_basics/","text":"5: Defining the Structure in Construct As mentioned earlier, Construct is a library designed to work specifically in Python, but it's functionality is similar to the functionality of Kaitai, just with more programmatic language. In Construct, we define Structs which are similar to types in Kaitai. By describing the structure of different sections of the data byte by byte, Structs can be combined with each other to capture larger sections of the data until they're combined in one final Struct which can capture all of the file's data. We can start by opening the github page for Construct at the definition for .gif . 5.1 Structs In Construct, a Struct is a collection of ordered and (usually) named fields that are parsed or built in the defined order. The object can then be either parsed when reading in a file's data or built to create a file with the type definitions. When a Struct is parsed, values are returned in a dictionary with keys matching the defined names, but names aren't strictly necessary like they are in Kaitai. It's possible to instead build from nothing and return nothing when parsing, so a name can be skipped in those instances. To recreate our dimension example from the Kaitai section, we can define a Struct as: dimensions = Struct( \"width\" / Int16ul, \"height\" / Int16ul ) Int16ul here means that we are deciphering the width and height as an Int eger of 16 u nsigned bits in l ittle endian format. To show how that type could then be used elsewhere, we could define another Struct using it: example = Struct( \"dimensions\" / dimensions ) When we look at gif.py , we can see that the structure is almost reversed when compared to Kaitai. This is because the structures in Kaitai are global - the order is arbitrary as long as they're placed in the right sections ( types or seq ), while in Construct the structures must be defined in order - one Struct can't use another until the other is defined. Let's try looking at the file backwards then, starting with the final Struct on line 121: gif_file = Struct( \"signature\" / Const(b\"GIF\"), \"version\" / Const(b\"89a\"), \"logical_screen\" / gif_logical_screen, \"data\" / GreedyRange(gif_data), # Const(Int8ul(\"trailer\"), 0x3B) ) In the gif_file Struct, we can see that instead of there being a defined header Struct , we can instead grab the signature and version as Const (constant) types, which functions much like the magic keyword in Kaitai. The only downside to doing it this way as opposed to setting a Struct earlier is that it will fail to parse if the version is different than the defined 89a . After those, we see \"logical_screen\" / gif_logical_screen , \"data\" / GreedyRange(gif_data) , and an optional (commented out) Const(Int8ul(\"trailer\"), 0x3B) . Let's start by looking at our logical_screen struct which can be found at line 20 to see how it is defined in Construct: gif_logical_screen = Struct( \"width\" / Int16ul, \"height\" / Int16ul, \"flags\" / BitStruct( \"global_color_table\" / Bit, \"color_resolution\" / BitsInteger(3), \"sort_flag\" / Bit, \"global_color_table_bpp\" / BitsInteger(3), ), \"bgcolor_index\" / Int8ul, \"pixel_aspect_ratio\" / Int8ul, \"palette\" / If(this.flags.global_color_table, Array(lambda this: 2**(this.flags.global_color_table_bpp + 1), Struct( \"R\" / Int8ul, \"G\" / Int8ul, \"B\" / Int8ul, ))), ) Here we can see that width and height have the expected definitions, but flags is using something called a BitStruct . These are much like a normal Struct , but designed to operate on bits instead of bytes. In parsing these, the data is converted to a stream of \\x01 and \\x00 s ( 1 s and 0 s) and then fed into the subconstructs. So global_color_table grabs just the first bit, color_resolution grabs the next 3 bits and parses them as an integer, etc. These values are then used in palette if global_color_table is True ( 1 ), and an Array is constructed with a length determined by raising 2 to the power of global_color_table_bpp + 1 where each element in the array is another Struct defining the RGB values of each pixel.","title":"Construct basics"},{"location":"construct_basics/#5-defining-the-structure-in-construct","text":"As mentioned earlier, Construct is a library designed to work specifically in Python, but it's functionality is similar to the functionality of Kaitai, just with more programmatic language. In Construct, we define Structs which are similar to types in Kaitai. By describing the structure of different sections of the data byte by byte, Structs can be combined with each other to capture larger sections of the data until they're combined in one final Struct which can capture all of the file's data. We can start by opening the github page for Construct at the definition for .gif .","title":"5: Defining the Structure in Construct"},{"location":"construct_basics/#51-structs","text":"In Construct, a Struct is a collection of ordered and (usually) named fields that are parsed or built in the defined order. The object can then be either parsed when reading in a file's data or built to create a file with the type definitions. When a Struct is parsed, values are returned in a dictionary with keys matching the defined names, but names aren't strictly necessary like they are in Kaitai. It's possible to instead build from nothing and return nothing when parsing, so a name can be skipped in those instances. To recreate our dimension example from the Kaitai section, we can define a Struct as: dimensions = Struct( \"width\" / Int16ul, \"height\" / Int16ul ) Int16ul here means that we are deciphering the width and height as an Int eger of 16 u nsigned bits in l ittle endian format. To show how that type could then be used elsewhere, we could define another Struct using it: example = Struct( \"dimensions\" / dimensions ) When we look at gif.py , we can see that the structure is almost reversed when compared to Kaitai. This is because the structures in Kaitai are global - the order is arbitrary as long as they're placed in the right sections ( types or seq ), while in Construct the structures must be defined in order - one Struct can't use another until the other is defined. Let's try looking at the file backwards then, starting with the final Struct on line 121: gif_file = Struct( \"signature\" / Const(b\"GIF\"), \"version\" / Const(b\"89a\"), \"logical_screen\" / gif_logical_screen, \"data\" / GreedyRange(gif_data), # Const(Int8ul(\"trailer\"), 0x3B) ) In the gif_file Struct, we can see that instead of there being a defined header Struct , we can instead grab the signature and version as Const (constant) types, which functions much like the magic keyword in Kaitai. The only downside to doing it this way as opposed to setting a Struct earlier is that it will fail to parse if the version is different than the defined 89a . After those, we see \"logical_screen\" / gif_logical_screen , \"data\" / GreedyRange(gif_data) , and an optional (commented out) Const(Int8ul(\"trailer\"), 0x3B) . Let's start by looking at our logical_screen struct which can be found at line 20 to see how it is defined in Construct: gif_logical_screen = Struct( \"width\" / Int16ul, \"height\" / Int16ul, \"flags\" / BitStruct( \"global_color_table\" / Bit, \"color_resolution\" / BitsInteger(3), \"sort_flag\" / Bit, \"global_color_table_bpp\" / BitsInteger(3), ), \"bgcolor_index\" / Int8ul, \"pixel_aspect_ratio\" / Int8ul, \"palette\" / If(this.flags.global_color_table, Array(lambda this: 2**(this.flags.global_color_table_bpp + 1), Struct( \"R\" / Int8ul, \"G\" / Int8ul, \"B\" / Int8ul, ))), ) Here we can see that width and height have the expected definitions, but flags is using something called a BitStruct . These are much like a normal Struct , but designed to operate on bits instead of bytes. In parsing these, the data is converted to a stream of \\x01 and \\x00 s ( 1 s and 0 s) and then fed into the subconstructs. So global_color_table grabs just the first bit, color_resolution grabs the next 3 bits and parses them as an integer, etc. These values are then used in palette if global_color_table is True ( 1 ), and an Array is constructed with a length determined by raising 2 to the power of global_color_table_bpp + 1 where each element in the array is another Struct defining the RGB values of each pixel.","title":"5.1 Structs"},{"location":"filetype/","text":"3: What is a file type? While it's easy to say that a .jpg \"is a picture\", a .gif \"is an animation\", or a .txt \"is a text document\" let's back up and think about how data is stored on a computer and translated into something that we can read and understand. Humans have invented what are now pretty familiar systems for interacting with computers, but it's important to remember that we interact with computers through several layers of culturally specific translations, abstractions, and conveniences that exist as barriers between our world of symbols and the laws of electromagnetism. We have spent much of the last century learning to shape metals and electricity into incredibly complex devices which we call things like \"processing units\" or \"graphics cards\". These tools can then deliver us images on demand of things that we call \"cats\", or even graphs to represent something called \"the economy\" when combined with a monitor of some kind. The point being that every file type is custom. Someone, somewhere, created a set of instructions which can be used to teach a computer program how to load a specific file format. A file type describes the extension which is used at the end of a file's name, such as .jpg , .gif , or .txt . The extension tells a program which format to use to read a given file. It is possible for different file types to share file formats, such as .jpg and .jpeg , and it is also possible for different file formats to share a file type, such as .bin . The .bin (short for binary) file type can be used to describe file formats ranging from executable binary files, game ROMs, or even CD/DVD data. File formats and file types both exist as a set of conventions rather than as strict rules. However, if you try to open an executable binary file as a game ROM, the program is likely to produce errors or simply fail to correctly interpret the data - unless the program is already prepared for either possibility. As file types and formats become more niche and specific to a project, it is up to developers to define their new file formats and create the software necessary to read a string of 1 s and 0 s and return something that humans can understand. 3.1 Computer language and number systems In some sense, a file format is a set of instructions that a program needs in order to be able to successfully open and/or save a file. Given a collection of bytes, a program will perform a set of computations to determine how to convert those bytes into a human-readable format. When considering the string of 1 s and 0 s mentioned earlier, we can ask one of the fundamental questions of computer science: How are 1 s and 0 s generated in the first place? Let's say you want to take some data under an existing file type, such as writing your results down in a .txt document. When you type a character on your keyboard, the mechanical action presses conductive material into place against a complex printed circuit laying underneath the key, allowing for a current to flow through a distinct path. This isn't necessarily true for every method of documenting characters, such as touch screens or speech-to-text, but the underlying principle is still important to note. Woodford, Chris, (2022). Computer Keyboards https://www.explainthatstuff.com/computerkeyboards.html#keys The current will then enter the keyboard's microcontroller, its \"brain\", where the resulting signal is converted into a binary representation of 1 s and 0 s. However, even this familiar numerical representation is a convenient abstraction used to explain a physical system comprised of transistors and capacitors which exist inside of a computer's memory cells. The circuit which was completed by the key press allows for a current to flow from a power source to different systems in the computer, eventually charging a series of capacitors in its memory cells. When a capacitor is charged, we call it a 1 , and when it's discharged, we call it a 0 , representing the binary states available of charged or uncharged (this is completely thrown out of the window for quantum computing systems, but they are very much outside of the scope of this lesson). The series of charged/uncharged cells is then held and written from a specific location inside of the computer's Random Access Memory (RAM) chip until the file is saved, at which point it can be moved onto the computer's hard drive. This is true even if you save something using what has become known as \"the cloud\", a series of decentralized computers. Even on these, in order to save a file, some physical set of capacitors and transistors must be manipulated on a computer server. Normally, if you're paying for a \"cloud\" service, the servers are owned and operated by the company which you are paying, ideally with layers of encryption and security to protect your data. It's in this way that the typed character a gets translated into the binary representation 01100001 . Each character's binary representation can also be said to represent where in your keyboard's circuitry a current was and wasn't allowed to pass through specific paths. Each character one can type is thus represented by a byte , a number 8 digits long represented in the binary counting system. Binary is a base two counting system, meaning that one byte can represent any value between 00000000 and 11111111 , or any number between 0 and 255 when written in the familiar base ten (decimal) system. Ok, so what exactly is a \"base two\" counting system? 3.1.1 Counting in binary and hexadecimals To understand counting systems, remember that the number system humans are used to were derived almost entirely from the fact that our species happens to have 10 fingers. As a result, we use what is called a \"base 10\" or \"decimal\" counting system. If we happened to have 8 fingers, we would instead likely use a \"base 8\" counting system. In base 10, the number \"3125\" could be interpreted as there being a 3 in the \"thousand\" or $10^3$ place, a 1 in the \"hundred\" or $10^2$ place, a 2 in the \"ten\" or $10^1$ place and a 5 in the \"ones\" or $10^0$ place, so: $$3125 = (3 \\cdot 10^3) + (1 \\cdot 10^2) + (2 \\cdot 10^1) + (5 \\cdot 10^0)$$ Each new digit to the left represents an additional $10^n$, where $n$ is the digit's index, starting from 0. This can be continued for digits representing numbers between 0 and 1 as well, or where $n < 0$. Here, $0.1$ can be equivalently represented as $(1 \\cdot 10^{-1})$, $0.01$ as $(1 \\cdot 10^{-2})$ and so on. The same is true for a binary counting system, only instead of the places being determined by powers of 10, they're determined by powers of 2. Binary is pretty simplistic as such, as any 1 or 0 simply means that there is or isn't a number in that place. So 01100001 becomes: $$(0 \\cdot 2^7) + (1 \\cdot 2^6) + (1 \\cdot 2^5) + (0 \\cdot 2^4) + (0 \\cdot 2^3) + (0 \\cdot 2^2) + (0 \\cdot 2^1) + (1 \\cdot 2^0)$$ Which when represented in decimal form becomes 97 . Another common numerical system that one should be familiar with when working with raw data is hexadecimals. While binary shortens the number of allowed symbols per digit to only 2 (0 & 1), hexadecimals is a base 16 counting system, extending the available symbols per digit from decimal's 10 (0-9) up to 16. To represent numbers larger than 9 in this system, we instead use the letters A-F, where A = 10, B = 11, ..., F = 15. Hexadecimal are used by software developers and the like because each hexadecimal digit can represent four bits (also known as a nibble or nybble ), meaning that one byte can be expressed in hexadecimal using only two characters. This makes the counting system much faster to represent, as 255 can be either 11111111 when represented in binary, or FF in hexadecimals. The letter a , can now be represented as 01100001 in binary, 97 in decimal or 61 in hexadecimals, following: $$(6 \\cdot 16^1) + (1 \\cdot 16^0)$$ To summarize, when you open a text editing program and begin recording data, every new typed character appends a number between 0 and 255 to the end of your document. Inside the components of your computer, this physically translates to a group of capacitors becoming charged or discharged. Other systems of the computer can then store and retrieve the positions of those capacitors as well as their current state. Then, when you open the file in a program, the values are assigned to different characters or other graphical representations depending on the program. Each program is provided with a set of instructions to translate these values into a representation of some kind. So, let's talk about that set of instructions next. How does your computer take what is essentially a large number saved on your computer's memory cards and turn it into a document you can understand? How do text editors know to open a .txt file and represent what it reads as 01100001 as the letter a ? 3.1.2 Endianness One of the first steps that a computer follows when opening a file relates to the system's endianness . This refers to the order that the computer will read the bytes of a given word , which is a fixed number of bytes, normally set by the computer's processor. There are two main types of endianness: big-endian (BE) or little-endian (LE). Let's say that your computer defines a word as four bytes. We can then think of endianness like writing down a 4-digit number on a piece of paper. Let's say we want to write the number 2024 : In big-endian, the number would be written straightforwardly: 2-0-2-4 . The most significant digit (the leftmost one) comes first, in the smallest memory address available to the computer, and the least significant digit (the rightmost one) comes last, in the largest memory address. In little-endian, this is reversed. The number would instead be written as: 4-2-0-2 , with the least significant digit being written to the smallest memory address, and the most significant digit being written to the largest memory address. If a file is saved using one endianness but opened using another, the bytes will be misinterpreted, like trying to read a book from the back to front. Many file formats will include a byte order mark ( BOM ) to indicate to the computer which endianness to use. 3.2 Opening a file with a text editor Plain text editors are pretty straightforward to understand. Generally, they convert all of the inputted data from binary into legible characters using encoding instructions such as the Unicode Transformation Format - 8-bit ( UTF-8 ) or the American Standard Code for Information Interchange ( ASCII ). UTF-8 is the preferred option, with 99% of average global use, but it was designed to be backwards compatible with ASCII , so the two systems share their first 128 characters. The map explaining how characters are selected from a given byte (converted into hexadecimals) looks like: UTF-8 Byte Map, from https://en.wikipedia.org/wiki/UTF-8#Byte_map Here, the row selects the first hex character of a byte and the column selects the second. You can find a here in row 6, column 1. Since your standard text editor translates all of the information of a file through UTF-8, it's pretty useful to illustrate what data is contained in other file types. Let's see what happens when we try to use a text editor to open a file type that it wasn't designed for, such as a GIF file. GIF stands for \"Graphics Interchange Format\", and is notable for being able to represent multiple images in a single file, so the file type is often used for animations. For this example, we'll be using a gif taken from Wikipedia's article on the subject of the file type: Rotating_earth_(large).gif, from https://en.wikipedia.org/wiki/GIF 3.2.1 Text editor setup Which text editor to use will depend on your operating system. Windows users should have access to the \"Notepad\" application, while on macOS the default text editor is called \"TextEdit\". For Linux users, your default text editor will depend on which distribution of Linux you're running. If you're unsure of which editor is available, search for \"default text editor\" + \" your distribution \" to find out. For Ubuntu users, the default editor is called \"Gedit\". For other distributions, common default text editors are Kate, Kwrite, and Geany. In general, it should be possible to simply right-click (or command-click for macOS) the file you intend to open and select the text editor that you wish to open the file with. If no text editor is available in the following drop-down menu, there should be an \"Open With\" option that will allow you to select a program to open the file. Otherwise, it is often possible to use your system's terminal to open a file, although the command for such will depend on your OS, the intended program, and the paths of the file and program. Using your terminal to open a file is generally the least efficient and straightforward method, but if it is the only one available to you, it is recommended to do an internet search for your terminal and the intended program, such as \"How to open a file in notepad using command prompt.\" Now that we have successfully opened a gif using a text editor file, the result should appear as a jumble of seemingly nonsensical characters, which should look something like the following in the case of the rotating globe gif. You might notice in that collection of seemingly random symbols that there are still some understandable combinations of characters, such as the first 3 which spell out \"GIF\", or further down on the left side you can find \"NETSCAPE2.0\". A program which was designed to open that file has instructions to use all of these seemingly random bytes to assign values to the width and height of a window in which to draw the image, the number of the frames that the image will be drawn on, and the RGB color of every pixel in every frame. While Kaitai and Construct aren't designed to show you the final animation, they are designed to allow you to translate the raw data into something usable so that you can then load all of that information elsewhere.","title":"File types"},{"location":"filetype/#3-what-is-a-file-type","text":"While it's easy to say that a .jpg \"is a picture\", a .gif \"is an animation\", or a .txt \"is a text document\" let's back up and think about how data is stored on a computer and translated into something that we can read and understand. Humans have invented what are now pretty familiar systems for interacting with computers, but it's important to remember that we interact with computers through several layers of culturally specific translations, abstractions, and conveniences that exist as barriers between our world of symbols and the laws of electromagnetism. We have spent much of the last century learning to shape metals and electricity into incredibly complex devices which we call things like \"processing units\" or \"graphics cards\". These tools can then deliver us images on demand of things that we call \"cats\", or even graphs to represent something called \"the economy\" when combined with a monitor of some kind. The point being that every file type is custom. Someone, somewhere, created a set of instructions which can be used to teach a computer program how to load a specific file format. A file type describes the extension which is used at the end of a file's name, such as .jpg , .gif , or .txt . The extension tells a program which format to use to read a given file. It is possible for different file types to share file formats, such as .jpg and .jpeg , and it is also possible for different file formats to share a file type, such as .bin . The .bin (short for binary) file type can be used to describe file formats ranging from executable binary files, game ROMs, or even CD/DVD data. File formats and file types both exist as a set of conventions rather than as strict rules. However, if you try to open an executable binary file as a game ROM, the program is likely to produce errors or simply fail to correctly interpret the data - unless the program is already prepared for either possibility. As file types and formats become more niche and specific to a project, it is up to developers to define their new file formats and create the software necessary to read a string of 1 s and 0 s and return something that humans can understand.","title":"3: What is a file type?"},{"location":"filetype/#31-computer-language-and-number-systems","text":"In some sense, a file format is a set of instructions that a program needs in order to be able to successfully open and/or save a file. Given a collection of bytes, a program will perform a set of computations to determine how to convert those bytes into a human-readable format. When considering the string of 1 s and 0 s mentioned earlier, we can ask one of the fundamental questions of computer science: How are 1 s and 0 s generated in the first place? Let's say you want to take some data under an existing file type, such as writing your results down in a .txt document. When you type a character on your keyboard, the mechanical action presses conductive material into place against a complex printed circuit laying underneath the key, allowing for a current to flow through a distinct path. This isn't necessarily true for every method of documenting characters, such as touch screens or speech-to-text, but the underlying principle is still important to note. Woodford, Chris, (2022). Computer Keyboards https://www.explainthatstuff.com/computerkeyboards.html#keys The current will then enter the keyboard's microcontroller, its \"brain\", where the resulting signal is converted into a binary representation of 1 s and 0 s. However, even this familiar numerical representation is a convenient abstraction used to explain a physical system comprised of transistors and capacitors which exist inside of a computer's memory cells. The circuit which was completed by the key press allows for a current to flow from a power source to different systems in the computer, eventually charging a series of capacitors in its memory cells. When a capacitor is charged, we call it a 1 , and when it's discharged, we call it a 0 , representing the binary states available of charged or uncharged (this is completely thrown out of the window for quantum computing systems, but they are very much outside of the scope of this lesson). The series of charged/uncharged cells is then held and written from a specific location inside of the computer's Random Access Memory (RAM) chip until the file is saved, at which point it can be moved onto the computer's hard drive. This is true even if you save something using what has become known as \"the cloud\", a series of decentralized computers. Even on these, in order to save a file, some physical set of capacitors and transistors must be manipulated on a computer server. Normally, if you're paying for a \"cloud\" service, the servers are owned and operated by the company which you are paying, ideally with layers of encryption and security to protect your data. It's in this way that the typed character a gets translated into the binary representation 01100001 . Each character's binary representation can also be said to represent where in your keyboard's circuitry a current was and wasn't allowed to pass through specific paths. Each character one can type is thus represented by a byte , a number 8 digits long represented in the binary counting system. Binary is a base two counting system, meaning that one byte can represent any value between 00000000 and 11111111 , or any number between 0 and 255 when written in the familiar base ten (decimal) system. Ok, so what exactly is a \"base two\" counting system?","title":"3.1 Computer language and number systems"},{"location":"filetype/#311-counting-in-binary-and-hexadecimals","text":"To understand counting systems, remember that the number system humans are used to were derived almost entirely from the fact that our species happens to have 10 fingers. As a result, we use what is called a \"base 10\" or \"decimal\" counting system. If we happened to have 8 fingers, we would instead likely use a \"base 8\" counting system. In base 10, the number \"3125\" could be interpreted as there being a 3 in the \"thousand\" or $10^3$ place, a 1 in the \"hundred\" or $10^2$ place, a 2 in the \"ten\" or $10^1$ place and a 5 in the \"ones\" or $10^0$ place, so: $$3125 = (3 \\cdot 10^3) + (1 \\cdot 10^2) + (2 \\cdot 10^1) + (5 \\cdot 10^0)$$ Each new digit to the left represents an additional $10^n$, where $n$ is the digit's index, starting from 0. This can be continued for digits representing numbers between 0 and 1 as well, or where $n < 0$. Here, $0.1$ can be equivalently represented as $(1 \\cdot 10^{-1})$, $0.01$ as $(1 \\cdot 10^{-2})$ and so on. The same is true for a binary counting system, only instead of the places being determined by powers of 10, they're determined by powers of 2. Binary is pretty simplistic as such, as any 1 or 0 simply means that there is or isn't a number in that place. So 01100001 becomes: $$(0 \\cdot 2^7) + (1 \\cdot 2^6) + (1 \\cdot 2^5) + (0 \\cdot 2^4) + (0 \\cdot 2^3) + (0 \\cdot 2^2) + (0 \\cdot 2^1) + (1 \\cdot 2^0)$$ Which when represented in decimal form becomes 97 . Another common numerical system that one should be familiar with when working with raw data is hexadecimals. While binary shortens the number of allowed symbols per digit to only 2 (0 & 1), hexadecimals is a base 16 counting system, extending the available symbols per digit from decimal's 10 (0-9) up to 16. To represent numbers larger than 9 in this system, we instead use the letters A-F, where A = 10, B = 11, ..., F = 15. Hexadecimal are used by software developers and the like because each hexadecimal digit can represent four bits (also known as a nibble or nybble ), meaning that one byte can be expressed in hexadecimal using only two characters. This makes the counting system much faster to represent, as 255 can be either 11111111 when represented in binary, or FF in hexadecimals. The letter a , can now be represented as 01100001 in binary, 97 in decimal or 61 in hexadecimals, following: $$(6 \\cdot 16^1) + (1 \\cdot 16^0)$$ To summarize, when you open a text editing program and begin recording data, every new typed character appends a number between 0 and 255 to the end of your document. Inside the components of your computer, this physically translates to a group of capacitors becoming charged or discharged. Other systems of the computer can then store and retrieve the positions of those capacitors as well as their current state. Then, when you open the file in a program, the values are assigned to different characters or other graphical representations depending on the program. Each program is provided with a set of instructions to translate these values into a representation of some kind. So, let's talk about that set of instructions next. How does your computer take what is essentially a large number saved on your computer's memory cards and turn it into a document you can understand? How do text editors know to open a .txt file and represent what it reads as 01100001 as the letter a ?","title":"3.1.1 Counting in binary and hexadecimals"},{"location":"filetype/#312-endianness","text":"One of the first steps that a computer follows when opening a file relates to the system's endianness . This refers to the order that the computer will read the bytes of a given word , which is a fixed number of bytes, normally set by the computer's processor. There are two main types of endianness: big-endian (BE) or little-endian (LE). Let's say that your computer defines a word as four bytes. We can then think of endianness like writing down a 4-digit number on a piece of paper. Let's say we want to write the number 2024 : In big-endian, the number would be written straightforwardly: 2-0-2-4 . The most significant digit (the leftmost one) comes first, in the smallest memory address available to the computer, and the least significant digit (the rightmost one) comes last, in the largest memory address. In little-endian, this is reversed. The number would instead be written as: 4-2-0-2 , with the least significant digit being written to the smallest memory address, and the most significant digit being written to the largest memory address. If a file is saved using one endianness but opened using another, the bytes will be misinterpreted, like trying to read a book from the back to front. Many file formats will include a byte order mark ( BOM ) to indicate to the computer which endianness to use.","title":"3.1.2 Endianness"},{"location":"filetype/#32-opening-a-file-with-a-text-editor","text":"Plain text editors are pretty straightforward to understand. Generally, they convert all of the inputted data from binary into legible characters using encoding instructions such as the Unicode Transformation Format - 8-bit ( UTF-8 ) or the American Standard Code for Information Interchange ( ASCII ). UTF-8 is the preferred option, with 99% of average global use, but it was designed to be backwards compatible with ASCII , so the two systems share their first 128 characters. The map explaining how characters are selected from a given byte (converted into hexadecimals) looks like: UTF-8 Byte Map, from https://en.wikipedia.org/wiki/UTF-8#Byte_map Here, the row selects the first hex character of a byte and the column selects the second. You can find a here in row 6, column 1. Since your standard text editor translates all of the information of a file through UTF-8, it's pretty useful to illustrate what data is contained in other file types. Let's see what happens when we try to use a text editor to open a file type that it wasn't designed for, such as a GIF file. GIF stands for \"Graphics Interchange Format\", and is notable for being able to represent multiple images in a single file, so the file type is often used for animations. For this example, we'll be using a gif taken from Wikipedia's article on the subject of the file type: Rotating_earth_(large).gif, from https://en.wikipedia.org/wiki/GIF","title":"3.2 Opening a file with a text editor"},{"location":"filetype/#321-text-editor-setup","text":"Which text editor to use will depend on your operating system. Windows users should have access to the \"Notepad\" application, while on macOS the default text editor is called \"TextEdit\". For Linux users, your default text editor will depend on which distribution of Linux you're running. If you're unsure of which editor is available, search for \"default text editor\" + \" your distribution \" to find out. For Ubuntu users, the default editor is called \"Gedit\". For other distributions, common default text editors are Kate, Kwrite, and Geany. In general, it should be possible to simply right-click (or command-click for macOS) the file you intend to open and select the text editor that you wish to open the file with. If no text editor is available in the following drop-down menu, there should be an \"Open With\" option that will allow you to select a program to open the file. Otherwise, it is often possible to use your system's terminal to open a file, although the command for such will depend on your OS, the intended program, and the paths of the file and program. Using your terminal to open a file is generally the least efficient and straightforward method, but if it is the only one available to you, it is recommended to do an internet search for your terminal and the intended program, such as \"How to open a file in notepad using command prompt.\" Now that we have successfully opened a gif using a text editor file, the result should appear as a jumble of seemingly nonsensical characters, which should look something like the following in the case of the rotating globe gif. You might notice in that collection of seemingly random symbols that there are still some understandable combinations of characters, such as the first 3 which spell out \"GIF\", or further down on the left side you can find \"NETSCAPE2.0\". A program which was designed to open that file has instructions to use all of these seemingly random bytes to assign values to the width and height of a window in which to draw the image, the number of the frames that the image will be drawn on, and the RGB color of every pixel in every frame. While Kaitai and Construct aren't designed to show you the final animation, they are designed to allow you to translate the raw data into something usable so that you can then load all of that information elsewhere.","title":"3.2.1 Text editor setup"},{"location":"introduction/","text":"1: Introduction It's common in the scientific community to record data in a custom format which might be unreadable to existing applications or programming languages. This means that in the processes of data analysis for a project, it can sometimes be necessary to create and describe a new file type and/or format. This lesson will be exploring first how to setup your computer to use the Kaitai language and Construct library before explaing how they can be used to translate one's custom binary data to make it easier to use. Kaitai can be utilized in Python, CSharp, Java, Javascript, Perl, PHP, or Ruby, while Construct is designed specifically for use with Python.","title":"Introduction"},{"location":"introduction/#1-introduction","text":"It's common in the scientific community to record data in a custom format which might be unreadable to existing applications or programming languages. This means that in the processes of data analysis for a project, it can sometimes be necessary to create and describe a new file type and/or format. This lesson will be exploring first how to setup your computer to use the Kaitai language and Construct library before explaing how they can be used to translate one's custom binary data to make it easier to use. Kaitai can be utilized in Python, CSharp, Java, Javascript, Perl, PHP, or Ruby, while Construct is designed specifically for use with Python.","title":"1: Introduction"},{"location":"kaitai_basics/","text":"4: Defining the Structure in Kaitai Let's try loading the GIF file in the Kaitai Web IDE to understand this better. Start by navigating to the Web IDE if you don't already have it open. 4.1 Anatomy of the Web IDE On the left side of the webpage, you'll see a list of folders, each containing pre-built .ksy files which you can use to test functionality. For this example, navigate to formats/image/gif.ksy , and double click gif.ksy to load it into the IDE. The buttons on the bottom left of the webpage are for creating new .ksy files, uploading .ksy or data files, and saving .ksy files respectively: New, Upload, Save Click the upload button to select a .gif file from your computer and load it here. You should now see a webpage that looks like: The viewer on the far right side should look somewhat familiar: it's the same data as when the file was opened in Notepad, now just with several of the unreadable symbols replaced with . s instead of Notepad's \u0010 symbol, showing the typeable characters alongside their hexadecimal representations. If you click to highlight specific characters or sets of characters on either side of the hex viewer , the corresponding characters will be highlighted on the other side as well, allowing you to see both the hex code and UTF-8/ASCII representations for any selection. This is also true for the object tree section. By clicking on an item in the object tree underneath the .ksy file such as the hdr section, the bytes described by the section are automatically selected in the hex viewer . In the same window as the hex viewer are the JS Code and JS Code (debug) sections. These show how the .ksy file is being translated in the JavaScript programming language alongside a debugger. The converter section on the bottom right of the screen provides multiple different possible ways to convert selected characters. These show different methods of translating a hex code as an integer, such as i8 , which is an 8-bit integer, i16le which is a 16-bit integer in little endian format, and so on. Finally, there is the info panel which provides information about a selection of bytes, such as the length of the selection and where in the data stream the selection is. If you are interested in following along more precisely with the gif.ksy file, there is also extensive documentation provided to describe the file format. Having documentation about the file format is crucial for describing your file type. Without documentation to follow, this process looks less like declarative programming and more like cryptography, as you would have to decipher the purpose of much of the binary data unless it happens to be written in plain text already. It's not impossible, just definitely not an ideal or efficient method. We won't fully describe everything being done in the example .ksy file here, instead we are just going to look at a broad overview to give an idea of how to use the program. Now that we know what we're looking at in the IDE, we can take a look at how the file type is being described. 4.2 meta and seq Your .ksy files should always start with a meta section, defining the meta-information of your file type such as the file extension (like .gif or .tiff , etc), titles, licenses, endianness (what byte-order the file should be read in), cross-references, miscellaneous documentation (like lines 17-33 of gif.ksy ), versions, types, encodings, etc. The seq section is where the declarative work really starts. In seq , we can begin to describe how to handle the raw data. While it is possible to directly define streams in seq , it is necessary to first declare an id which will be the name shown in the object tree for any given attribute. You can also specify information such as a type , which tells the IDE what to do with the data in that section, a size which states the number of bytes for the object to capture, content can be specified for magic signatures, encoding choice can be determined here, etc. The types are then executed in the order that they're declared in seq , meaning that when reading the raw data of our gif, it'll apply the header type until its type conditions are fulfilled, then logical_screen_descriptor_struct , then color_table , and finally blocks . If for some reason any of the type conditions are unable to be fulfilled, the IDE will interrupt parsing and display an error message underneath the object tree. Instead of investigating all four different types in the file's seq , let's instead look only at the first two: header and logical_screen_descriptor to get a better idea of how Kaitai operates. 4.3 Types The types section is where it becomes vital to reference documentation around the file type you're trying to parse. A link to the documentation is provided in the gif.ksy file for the first time on line 43 for the glocal_color_table section, pointing the user to section 18 of the Cover Sheet for the GIF89a Specification . While it takes around 150 lines of code to full describe the types in gif.ksy (from line 48-197), longer descriptions aren't always necessary depending on the scope of your project. For instance, if you would expect the first 4 bytes to identify an object's width and height, your type could be settled quickly in the main seq section without ever having to create a type description, as: seq: - id: width type: u2 - id: height type: u2 In this example, u2 could be replaced with s1 , s2 , s4 , u1 , u2 , u4 , etc, where s or u stands for signed or unsigned bytes, and the number tells the IDE how many bytes to read of that type. However, if we knew that we would later need to grab a different width and height for some reason, we could instead write this as: seq: - id: dimensions type: width_and_height ... types: width_and_height: seq: - id: width type: u2 - id: height type: u2 The former method is useful for simple, straightforward data, while the latter is useful for describing repetitive data structures or for reusing types. It allows you to consolidate multiple types into a single place, to repeat types, or to use certain types in the definitions of other types. When looking at gif.ksy 's header type, we see: header: doc-ref: https://www.w3.org/Graphics/GIF/spec-gif89a.txt - section 17 seq: - id: magic contents: 'GIF' - id: version type: str size: 3 encoding: ASCII The keyword magic is especially useful here as a type of safeguard, acting as a file signature when paired with the contents key. It simply checks that the first bytes match up with the contents, \"GIF\" in this case. The magic id is then followed by version , which simply grabs the next 3 bytes as denoted by size using the built in str (string) type, and specifies that it is using ASCII encoding. This also highlights one of the bigger strengths of Kaitai - its readability. For the most part, it's a very straightforward language. This strength is also apparent in the next type, logical_screen_descriptor_struct : logical_screen_descriptor_struct: doc-ref: https://www.w3.org/Graphics/GIF/spec-gif89a.txt - section 18 seq: - id: screen_width type: u2 - id: screen_height type: u2 - id: flags type: u1 - id: bg_color_index type: u1 - id: pixel_aspect_ratio type: u1 instances: has_color_table: value: '(flags & 0b10000000) != 0' color_table_size: value: '2 << (flags & 7)' As you can see, it simply grabs the width and the height of the screen on which the gif will be drawn as 2 unsigned bytes, followed by three unsigned bytes that describe the flags , bg_color_index , and pixel_aspect_ratio . 4.3.1 Instances After the id s are set in the type seq , we then see an instances section. This section is setting new variables by manipulating the previously found flags object using Kaitai's expression language. value: '(flags & 0b10000000) !=0' is doing something called \"bit masking\"; taking the bits from the flag byte and showing only the first one. The beginning 0b simply means to read the flags object as bytes for the masking, then the 1 means the first bit is allowed through while the rest are masked with 0 , so are blocked from being read. The value is set as True or False depending on if the first bit is NOT ( != ) equal to 0. This is a boolean operation - either the gif does or does not have a color table, which is revealed by the first bit in the flags byte. This is a good time to mention that bytes are not some kind of fundamental unit of computation. The choice to have 8 bits in one byte was a decision made by the International Organization for Standardization (ISO) and the International Electrotechnical Commmission (IEC) in 1993, but 6 and 9 bit bytes were common through the 1960s. Bit masking can allow for one to use every individual bit or combination of bits in a selection to correspond to a different value. In this way, one can surpass some of the artificially imposed limits on computation. color_table_size is doing a similar operation but with different syntax. 7 in binary is 00000111 , so (flags & 7) is selecting the final 3 bits. 2 in binary is 00000010 - << is the command to shift bits to the left, so that command shifts 2 to the left by flags & 7 places. This is equivalent to raising 2 to the power of 1+(flags mod 8) and then assigning that new value to a character. In our case, flags = 247, or 11110111 , so has_color_table = True , and 1+(flags mod 8) = 8 , $2^8 = 256$, so color_table_size = 256 All of this section has been to explain, in broad strokes, some of the types as shown in the GIF file type. If you're interested in reading more about Kaitai Struct Language, the full documentation can be found here . For now, let's continue this lesson and talk about how this same file type definition can be done with the Construct library.","title":"Kaitai basics"},{"location":"kaitai_basics/#4-defining-the-structure-in-kaitai","text":"Let's try loading the GIF file in the Kaitai Web IDE to understand this better. Start by navigating to the Web IDE if you don't already have it open.","title":"4: Defining the Structure in Kaitai"},{"location":"kaitai_basics/#41-anatomy-of-the-web-ide","text":"On the left side of the webpage, you'll see a list of folders, each containing pre-built .ksy files which you can use to test functionality. For this example, navigate to formats/image/gif.ksy , and double click gif.ksy to load it into the IDE. The buttons on the bottom left of the webpage are for creating new .ksy files, uploading .ksy or data files, and saving .ksy files respectively: New, Upload, Save Click the upload button to select a .gif file from your computer and load it here. You should now see a webpage that looks like: The viewer on the far right side should look somewhat familiar: it's the same data as when the file was opened in Notepad, now just with several of the unreadable symbols replaced with . s instead of Notepad's \u0010 symbol, showing the typeable characters alongside their hexadecimal representations. If you click to highlight specific characters or sets of characters on either side of the hex viewer , the corresponding characters will be highlighted on the other side as well, allowing you to see both the hex code and UTF-8/ASCII representations for any selection. This is also true for the object tree section. By clicking on an item in the object tree underneath the .ksy file such as the hdr section, the bytes described by the section are automatically selected in the hex viewer . In the same window as the hex viewer are the JS Code and JS Code (debug) sections. These show how the .ksy file is being translated in the JavaScript programming language alongside a debugger. The converter section on the bottom right of the screen provides multiple different possible ways to convert selected characters. These show different methods of translating a hex code as an integer, such as i8 , which is an 8-bit integer, i16le which is a 16-bit integer in little endian format, and so on. Finally, there is the info panel which provides information about a selection of bytes, such as the length of the selection and where in the data stream the selection is. If you are interested in following along more precisely with the gif.ksy file, there is also extensive documentation provided to describe the file format. Having documentation about the file format is crucial for describing your file type. Without documentation to follow, this process looks less like declarative programming and more like cryptography, as you would have to decipher the purpose of much of the binary data unless it happens to be written in plain text already. It's not impossible, just definitely not an ideal or efficient method. We won't fully describe everything being done in the example .ksy file here, instead we are just going to look at a broad overview to give an idea of how to use the program. Now that we know what we're looking at in the IDE, we can take a look at how the file type is being described.","title":"4.1 Anatomy of the Web IDE"},{"location":"kaitai_basics/#42-meta-and-seq","text":"Your .ksy files should always start with a meta section, defining the meta-information of your file type such as the file extension (like .gif or .tiff , etc), titles, licenses, endianness (what byte-order the file should be read in), cross-references, miscellaneous documentation (like lines 17-33 of gif.ksy ), versions, types, encodings, etc. The seq section is where the declarative work really starts. In seq , we can begin to describe how to handle the raw data. While it is possible to directly define streams in seq , it is necessary to first declare an id which will be the name shown in the object tree for any given attribute. You can also specify information such as a type , which tells the IDE what to do with the data in that section, a size which states the number of bytes for the object to capture, content can be specified for magic signatures, encoding choice can be determined here, etc. The types are then executed in the order that they're declared in seq , meaning that when reading the raw data of our gif, it'll apply the header type until its type conditions are fulfilled, then logical_screen_descriptor_struct , then color_table , and finally blocks . If for some reason any of the type conditions are unable to be fulfilled, the IDE will interrupt parsing and display an error message underneath the object tree. Instead of investigating all four different types in the file's seq , let's instead look only at the first two: header and logical_screen_descriptor to get a better idea of how Kaitai operates.","title":"4.2 meta and seq"},{"location":"kaitai_basics/#43-types","text":"The types section is where it becomes vital to reference documentation around the file type you're trying to parse. A link to the documentation is provided in the gif.ksy file for the first time on line 43 for the glocal_color_table section, pointing the user to section 18 of the Cover Sheet for the GIF89a Specification . While it takes around 150 lines of code to full describe the types in gif.ksy (from line 48-197), longer descriptions aren't always necessary depending on the scope of your project. For instance, if you would expect the first 4 bytes to identify an object's width and height, your type could be settled quickly in the main seq section without ever having to create a type description, as: seq: - id: width type: u2 - id: height type: u2 In this example, u2 could be replaced with s1 , s2 , s4 , u1 , u2 , u4 , etc, where s or u stands for signed or unsigned bytes, and the number tells the IDE how many bytes to read of that type. However, if we knew that we would later need to grab a different width and height for some reason, we could instead write this as: seq: - id: dimensions type: width_and_height ... types: width_and_height: seq: - id: width type: u2 - id: height type: u2 The former method is useful for simple, straightforward data, while the latter is useful for describing repetitive data structures or for reusing types. It allows you to consolidate multiple types into a single place, to repeat types, or to use certain types in the definitions of other types. When looking at gif.ksy 's header type, we see: header: doc-ref: https://www.w3.org/Graphics/GIF/spec-gif89a.txt - section 17 seq: - id: magic contents: 'GIF' - id: version type: str size: 3 encoding: ASCII The keyword magic is especially useful here as a type of safeguard, acting as a file signature when paired with the contents key. It simply checks that the first bytes match up with the contents, \"GIF\" in this case. The magic id is then followed by version , which simply grabs the next 3 bytes as denoted by size using the built in str (string) type, and specifies that it is using ASCII encoding. This also highlights one of the bigger strengths of Kaitai - its readability. For the most part, it's a very straightforward language. This strength is also apparent in the next type, logical_screen_descriptor_struct : logical_screen_descriptor_struct: doc-ref: https://www.w3.org/Graphics/GIF/spec-gif89a.txt - section 18 seq: - id: screen_width type: u2 - id: screen_height type: u2 - id: flags type: u1 - id: bg_color_index type: u1 - id: pixel_aspect_ratio type: u1 instances: has_color_table: value: '(flags & 0b10000000) != 0' color_table_size: value: '2 << (flags & 7)' As you can see, it simply grabs the width and the height of the screen on which the gif will be drawn as 2 unsigned bytes, followed by three unsigned bytes that describe the flags , bg_color_index , and pixel_aspect_ratio .","title":"4.3 Types"},{"location":"kaitai_basics/#431-instances","text":"After the id s are set in the type seq , we then see an instances section. This section is setting new variables by manipulating the previously found flags object using Kaitai's expression language. value: '(flags & 0b10000000) !=0' is doing something called \"bit masking\"; taking the bits from the flag byte and showing only the first one. The beginning 0b simply means to read the flags object as bytes for the masking, then the 1 means the first bit is allowed through while the rest are masked with 0 , so are blocked from being read. The value is set as True or False depending on if the first bit is NOT ( != ) equal to 0. This is a boolean operation - either the gif does or does not have a color table, which is revealed by the first bit in the flags byte. This is a good time to mention that bytes are not some kind of fundamental unit of computation. The choice to have 8 bits in one byte was a decision made by the International Organization for Standardization (ISO) and the International Electrotechnical Commmission (IEC) in 1993, but 6 and 9 bit bytes were common through the 1960s. Bit masking can allow for one to use every individual bit or combination of bits in a selection to correspond to a different value. In this way, one can surpass some of the artificially imposed limits on computation. color_table_size is doing a similar operation but with different syntax. 7 in binary is 00000111 , so (flags & 7) is selecting the final 3 bits. 2 in binary is 00000010 - << is the command to shift bits to the left, so that command shifts 2 to the left by flags & 7 places. This is equivalent to raising 2 to the power of 1+(flags mod 8) and then assigning that new value to a character. In our case, flags = 247, or 11110111 , so has_color_table = True , and 1+(flags mod 8) = 8 , $2^8 = 256$, so color_table_size = 256 All of this section has been to explain, in broad strokes, some of the types as shown in the GIF file type. If you're interested in reading more about Kaitai Struct Language, the full documentation can be found here . For now, let's continue this lesson and talk about how this same file type definition can be done with the Construct library.","title":"4.3.1 Instances"},{"location":"putting_it_together/","text":"6: Putting it all together Now that we have the basics down, let's try putting it all together. To do this, let's fabricate some data, save that data in a binary file, and then define the structure for that data in both Kaitai and Construct. After that, we can compile our formats and begin to manipulate and work with this data. 6.1 Creating example data Let's say that the data that we're taking comes as a waveform in a binary file. We can pretend that we're measuring vibrations through some material or that we're measuring light intensity in some complex electrical system. As we're fabricating data, not actually measuring it, the justification is immaterial. For this example we'll be working in Python, simply because it is necessary for Construct. If you would prefer to follow along using a different programming language, that shouldn't cause any issues as long as the Construct description is written using Construct. If you don't already have an IDE installed, simply follow the link in section 2.2 Python Setup to install Spyder. Let's say that we want to break our data into 3 different sections depending on the intensity. The first section can describe the entire wave form, the second can capture only the mid-range values, and the third section captures only the most intense values. First, we'll need to make sure that all of the necessary libraries are installed and imported. For this data, we'll need the numpy library and the struct (not Construct) library. Optionally, we can also include matplotlib in order to plot our simulated data. To check if you already have these libraries installed, open your IDE's terminal and enter: pip list This will return an alphabetical list of all modules currently installed packages/modules that your install of Python has access to, as well as their version numbers. Simply scroll through the result to see if matplotlib , numpy , and python-struct are installed, and if not, run: pip install numpy pip install matplotlib pip install python_struct You should now be free to create a new .py or .ipynb file, named whatever you'd prefer. You will have to save the file before most IDEs will allow you to run the file. At the beginning of your new file, import the necessary modules using the commands: import numpy as np import struct import matplotlib.pyplot as plt Now, let's define 6 different arrays, one for each x and y value that is being selected from each different section. The x-axis is only useful here if you also plan on plotting the data: full_x = [] full_y = [] mid_x = [] mid_y = [] peak_x = [] peak_y = [] Next, we'll want to populate these arrays with their respective data. Let's create a for loop which will create a wave using an equation. For this example, I'll be creating a function that is defined from x=-5 to x=5 , creating a point every time x increases by 0.0001 , meaning the full data will contain 100000 points. The actual function chosen doesn't matter much as long as it's possible to graph in two dimensions - you can simply plot a cosine or sin function with arbitrary limits without running into any issues (as long as your computer can handle the amount of data): for i in np.arange(-5,5,0.0001): n = (np.cos((2 * np.pi * i**2)/(i**2 + i))) * np.sin(i) # Put every calculated point in full_x and full_y full_x.append(i) full_y.append(n) # Select only mid range points if n**2 < 0.3: mid_x.append(i) mid_y.append(n) # Select only extrema if n**2 > 0.65: peak_x.append(i) peak_y.append(n) You could now plot the three graphs if you wish to see what these produce by using: plt.scatter(full_x, full_y, s=1) plt.show() plt.scatter(mid_x, mid_y, s=1) plt.show() plt.scatter(peak_x, peak_y, s=1) plt.show() The resulting graphs should look like: Next, we'll want to describe the datatype so that we can save this data into numpy arrays before writing them into a binary file using numpy's dtype function: dtype = np.dtype([('string', 'S10'), ('float', np.float64)]) Here, we are defining a data type which has two fields: the first being a \"string\" field which stores fixed-sized strings up to 10 bytes (S10), the second being a \"float\" field which stores a 64-bit floating-point number (meaning that the number includes decimal points). We'll then want to use this datatype to structure our arrays: full_data = np.array([(f\"full_{index}\".encode('ascii'), value) for index, value in enumerate(full_y)], dtype=dtype) mid_data = np.array([(f\"mid_{index}\".encode('ascii'), value) for index, value in enumerate(mid_y)], dtype=dtype) peak_data = np.array([(f\"peak_{index}\".encode('ascii'), value) for index, value in enumerate(peak_y)], dtype=dtype) Here, enumerate(full/mid/peak_y) is being used to loop through each respective y-axis, where index is the position and value is the corresponding element from the axis. f\"full_{index}\" is creating a string for each index, like \"full_0\" , \"full_1\" , etc, and .encode('ascii') converts the string into an ASCII byte string ( \"full_0\" $\\to$ b'full_0' ). That section is then included in a tuple: (f\"full_{index}\".encode('ascii'), value) , where the first element is the encoded byte string and the second is the value taken from the y-axis. The next step is then to write all of this data into a new binary file. For this step, it's important to also include the length of each section. By doing this, we can state the size of each array without having to calculate it by hand or eyeball it in the data. It's simplest to include the length at the beginning of the file, although you could just as easily add the length of each section right before the data is included. The data is written in the order that it's listed in the following command: with open('wave_data.bin', 'wb') as f: # Provide lengths of each array f.write(struct.pack('I', len(full_data))) f.write(struct.pack('I', len(mid_data))) f.write(struct.pack('I', len(peak_data))) # Write each array onto the file full_data.tofile(f) mid_data.tofile(f) peak_data.tofile(f) We now have a file titled \"wave_data.bin\" saved in the same directory as our python program.","title":"Putting it together"},{"location":"putting_it_together/#6-putting-it-all-together","text":"Now that we have the basics down, let's try putting it all together. To do this, let's fabricate some data, save that data in a binary file, and then define the structure for that data in both Kaitai and Construct. After that, we can compile our formats and begin to manipulate and work with this data.","title":"6: Putting it all together"},{"location":"putting_it_together/#61-creating-example-data","text":"Let's say that the data that we're taking comes as a waveform in a binary file. We can pretend that we're measuring vibrations through some material or that we're measuring light intensity in some complex electrical system. As we're fabricating data, not actually measuring it, the justification is immaterial. For this example we'll be working in Python, simply because it is necessary for Construct. If you would prefer to follow along using a different programming language, that shouldn't cause any issues as long as the Construct description is written using Construct. If you don't already have an IDE installed, simply follow the link in section 2.2 Python Setup to install Spyder. Let's say that we want to break our data into 3 different sections depending on the intensity. The first section can describe the entire wave form, the second can capture only the mid-range values, and the third section captures only the most intense values. First, we'll need to make sure that all of the necessary libraries are installed and imported. For this data, we'll need the numpy library and the struct (not Construct) library. Optionally, we can also include matplotlib in order to plot our simulated data. To check if you already have these libraries installed, open your IDE's terminal and enter: pip list This will return an alphabetical list of all modules currently installed packages/modules that your install of Python has access to, as well as their version numbers. Simply scroll through the result to see if matplotlib , numpy , and python-struct are installed, and if not, run: pip install numpy pip install matplotlib pip install python_struct You should now be free to create a new .py or .ipynb file, named whatever you'd prefer. You will have to save the file before most IDEs will allow you to run the file. At the beginning of your new file, import the necessary modules using the commands: import numpy as np import struct import matplotlib.pyplot as plt Now, let's define 6 different arrays, one for each x and y value that is being selected from each different section. The x-axis is only useful here if you also plan on plotting the data: full_x = [] full_y = [] mid_x = [] mid_y = [] peak_x = [] peak_y = [] Next, we'll want to populate these arrays with their respective data. Let's create a for loop which will create a wave using an equation. For this example, I'll be creating a function that is defined from x=-5 to x=5 , creating a point every time x increases by 0.0001 , meaning the full data will contain 100000 points. The actual function chosen doesn't matter much as long as it's possible to graph in two dimensions - you can simply plot a cosine or sin function with arbitrary limits without running into any issues (as long as your computer can handle the amount of data): for i in np.arange(-5,5,0.0001): n = (np.cos((2 * np.pi * i**2)/(i**2 + i))) * np.sin(i) # Put every calculated point in full_x and full_y full_x.append(i) full_y.append(n) # Select only mid range points if n**2 < 0.3: mid_x.append(i) mid_y.append(n) # Select only extrema if n**2 > 0.65: peak_x.append(i) peak_y.append(n) You could now plot the three graphs if you wish to see what these produce by using: plt.scatter(full_x, full_y, s=1) plt.show() plt.scatter(mid_x, mid_y, s=1) plt.show() plt.scatter(peak_x, peak_y, s=1) plt.show() The resulting graphs should look like: Next, we'll want to describe the datatype so that we can save this data into numpy arrays before writing them into a binary file using numpy's dtype function: dtype = np.dtype([('string', 'S10'), ('float', np.float64)]) Here, we are defining a data type which has two fields: the first being a \"string\" field which stores fixed-sized strings up to 10 bytes (S10), the second being a \"float\" field which stores a 64-bit floating-point number (meaning that the number includes decimal points). We'll then want to use this datatype to structure our arrays: full_data = np.array([(f\"full_{index}\".encode('ascii'), value) for index, value in enumerate(full_y)], dtype=dtype) mid_data = np.array([(f\"mid_{index}\".encode('ascii'), value) for index, value in enumerate(mid_y)], dtype=dtype) peak_data = np.array([(f\"peak_{index}\".encode('ascii'), value) for index, value in enumerate(peak_y)], dtype=dtype) Here, enumerate(full/mid/peak_y) is being used to loop through each respective y-axis, where index is the position and value is the corresponding element from the axis. f\"full_{index}\" is creating a string for each index, like \"full_0\" , \"full_1\" , etc, and .encode('ascii') converts the string into an ASCII byte string ( \"full_0\" $\\to$ b'full_0' ). That section is then included in a tuple: (f\"full_{index}\".encode('ascii'), value) , where the first element is the encoded byte string and the second is the value taken from the y-axis. The next step is then to write all of this data into a new binary file. For this step, it's important to also include the length of each section. By doing this, we can state the size of each array without having to calculate it by hand or eyeball it in the data. It's simplest to include the length at the beginning of the file, although you could just as easily add the length of each section right before the data is included. The data is written in the order that it's listed in the following command: with open('wave_data.bin', 'wb') as f: # Provide lengths of each array f.write(struct.pack('I', len(full_data))) f.write(struct.pack('I', len(mid_data))) f.write(struct.pack('I', len(peak_data))) # Write each array onto the file full_data.tofile(f) mid_data.tofile(f) peak_data.tofile(f) We now have a file titled \"wave_data.bin\" saved in the same directory as our python program.","title":"6.1 Creating example data"},{"location":"setup/","text":"2: Setup Installation isn't strictly necessary for working with Kaitai, but is required for working with Construct. 2.1 Kaitai IDE For Kaitai, the Web IDE (Integrated Development Environment) is the simplest way to get started, and is all that is necessary for the majority of this lesson. If you're already familiar with the language you can use the Web IDE to jump straight in to describing your data format. If you're not familiar, it's recommended to read through the existing documentation . The instructions in section 4. Defining the Structure in Kaitai reference the documentation enough to describe one file type, but the actual documentation provides a much more complete description of Kaitai's syntax and its available commands. Advanced users may wish to install ksc , the kaitai-struct-compiler , and/or ksv , the kaitai-struct-visualizer , directly onto their own machine. Instructions to do so are included in the Advanced Kaitai Users section. 2.2 Python Setup In order to use Construct, it is necessary to have Python installed on your machine. If that is already the case for you and you are already familiar with an IDE of your choice, this section can be skipped. There are numerous IDEs with which one can use for programming in Python: Spyder, Anaconda, Visual Studio Code, and Pycharm are popular choices, just to name a few. For this lesson, it is recommended to install and familiarize yourself with the Spyder environment, which can be downloaded and installed from here . Spyder is an open-source program which was built in Python, for Python, specifically for use in data science. By following the link, you should have the option to download the IDE for your operating system (Windows, macOS, and Linux are supported), at which point you can follow the guided installation. The IDE should open after the installation is complete, at which point it is recommended to follow along with the tour for a quick overview of the IDE. 2.3 Construct Setup After installing the Python IDE of your choice, open or navigate to the console. In Spyder, the console is found as the window on the bottom right (by default), and should resemble the below image. If you're having trouble finding the console, or have removed the window by accident (or on purpose and are unsure how to return it), it should be possible to turn it back on by navigating to View > Panes > and checking the box next to IPython Console . Alternatively on Windows, you can also type CTRL+SHIFT+I to open or close the console window. Construct doesn't have any hard dependencies, but all supported modules can be installed as well with a single command. The basic version of Construct is enough for this lesson. To install it, you should only need to type or copy the following into the console and hit enter: pip install construct Advanced users can refer to the advanced section for further instructions.","title":"Setup"},{"location":"setup/#2-setup","text":"Installation isn't strictly necessary for working with Kaitai, but is required for working with Construct.","title":"2: Setup"},{"location":"setup/#21-kaitai-ide","text":"For Kaitai, the Web IDE (Integrated Development Environment) is the simplest way to get started, and is all that is necessary for the majority of this lesson. If you're already familiar with the language you can use the Web IDE to jump straight in to describing your data format. If you're not familiar, it's recommended to read through the existing documentation . The instructions in section 4. Defining the Structure in Kaitai reference the documentation enough to describe one file type, but the actual documentation provides a much more complete description of Kaitai's syntax and its available commands. Advanced users may wish to install ksc , the kaitai-struct-compiler , and/or ksv , the kaitai-struct-visualizer , directly onto their own machine. Instructions to do so are included in the Advanced Kaitai Users section.","title":"2.1 Kaitai IDE"},{"location":"setup/#22-python-setup","text":"In order to use Construct, it is necessary to have Python installed on your machine. If that is already the case for you and you are already familiar with an IDE of your choice, this section can be skipped. There are numerous IDEs with which one can use for programming in Python: Spyder, Anaconda, Visual Studio Code, and Pycharm are popular choices, just to name a few. For this lesson, it is recommended to install and familiarize yourself with the Spyder environment, which can be downloaded and installed from here . Spyder is an open-source program which was built in Python, for Python, specifically for use in data science. By following the link, you should have the option to download the IDE for your operating system (Windows, macOS, and Linux are supported), at which point you can follow the guided installation. The IDE should open after the installation is complete, at which point it is recommended to follow along with the tour for a quick overview of the IDE.","title":"2.2 Python Setup"},{"location":"setup/#23-construct-setup","text":"After installing the Python IDE of your choice, open or navigate to the console. In Spyder, the console is found as the window on the bottom right (by default), and should resemble the below image. If you're having trouble finding the console, or have removed the window by accident (or on purpose and are unsure how to return it), it should be possible to turn it back on by navigating to View > Panes > and checking the box next to IPython Console . Alternatively on Windows, you can also type CTRL+SHIFT+I to open or close the console window. Construct doesn't have any hard dependencies, but all supported modules can be installed as well with a single command. The basic version of Construct is enough for this lesson. To install it, you should only need to type or copy the following into the console and hit enter: pip install construct Advanced users can refer to the advanced section for further instructions.","title":"2.3 Construct Setup"}]}