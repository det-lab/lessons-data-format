{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Creating a custom data format","text":"<p>Created by Adrian Fisher</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md               # The documentation homepage.\n    setup.md               # Setting up kaitai and construct\n    filetype.md            # Describing file formats and types\n    kaitai_basics.md       # Describing the basics of using Kaitai\n    construct_basics.md    # Describing the basics of using Construct\n    putting_it_together.md # Creating fake data and learning to compile it\n    conclusion.md          # Conclusion (TODO)\n    advanced.md            # Section for advanced users\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"advanced/","title":"i: Advanced","text":""},{"location":"advanced/#advanced-kaitai-users","title":"Advanced Kaitai Users","text":"<p>There are several reasons that one might choose to install the <code>Kaitai-Struct-Compiler</code> directly onto their machines as opposed to using the Web IDE. The desktop and console versions can also be used when you're done using the Web IDE to compile the file for other programming languages. The different OS downloads are available with this link.</p> <p>After installation, you should have: * <code>ksc</code> (<code>kaitai-struct-compiler</code>) - a command line Kaitai Struct Compiler which translates <code>.ksy</code> files into parsing libraries for a chosen target language. * <code>ksv</code> (<code>kaitai-struct-visualizer</code>, optional) a console visualizer</p>"},{"location":"advanced/#advanced-construct-users","title":"Advanced Construct Users","text":"<p>While not necessary for this lesson, if you instead wish to install all the supported modules alongside your Construct install, instead type or copy the following and hit enter:</p> <pre><code>pip install construct[extras]\n</code></pre>"},{"location":"conclusion/","title":"7: Conclusion","text":"<p>TODO</p> <p>Include YT community dev mailing list (yt-dev@python.org), Professor Roberts' email, kaitai gitter link</p>"},{"location":"construct_basics/","title":"5: Defining the Structure in Construct","text":"<p>As mentioned earlier, Construct is a library designed to work specifically in Python, but it's functionality is similar to the functionality of Kaitai, just with more programmatic language. In Construct, we define <code>Structs</code> which are similar to <code>types</code> in Kaitai. After describing the structure of a section on the byte level, <code>Structs</code> can then be combined with each other to capture larger sections of the data until they're combined in a final <code>Struct</code> which captures all of the file's data.</p>"},{"location":"construct_basics/#51-struct-basics","title":"5.1 Struct basics","text":"<p>In Construct, a <code>Struct</code> is a collection of ordered and (usually) named fields that are then parsed or built in the defined order. The <code>Struct</code> can either used to parse a file's data or build a file that matches the file format. When a <code>Struct</code> is parsed, values are returned in a dictionary with keys matching the defined names, but names aren't strictly necessary like they are in Kaitai. It's possible to instead build from nothing and return nothing when parsing, so a name can be skipped in those instances. </p> <p>Let's recreate our dimension example from the Kaitai section. We can define the <code>dimensions</code> <code>Struct</code> with:</p> <pre><code>dimensions = Struct(\n    \"width\" / Int16ul,\n    \"height\" / Int16ul\n)\n</code></pre> <p><code>Int16ul</code> here means that we are deciphering the width and height as an Integer of 16 unsigned bits in little endian format. To show how that type could then be used elsewhere, we could define another <code>Struct</code> using it:</p> <pre><code>example = Struct(\n  \"dimensions\" / dimensions\n)\n</code></pre>"},{"location":"construct_basics/#52-building-gifpy","title":"5.2 Building gif.py","text":"<p>Ok, now let's take a look at how Construct defines a gif from the file gif.py in Construct's github. </p> <p>When we look at <code>gif.py</code>, we can see that the structure is essentially reversed when compared to Kaitai. All of the smaller, defining fields come first before they're put together into larger <code>Structs</code>. This is because the structures in Kaitai are global; the order is arbitrary as long as they're placed in the right sections (<code>types</code> or <code>seq</code>), while in Construct the structures must be defined in order - one <code>Struct</code> can't use another unless the other is already defined. Let's try looking at the file backwards then, starting with the final <code>Struct</code> on line 121:</p> <pre><code>gif_file = Struct(\n    \"signature\" / Const(b\"GIF\"),\n    \"version\" / Const(b\"89a\"),\n    \"logical_screen\" / gif_logical_screen,\n    \"data\" / GreedyRange(gif_data),\n    # Const(Int8ul(\"trailer\"), 0x3B)\n)\n</code></pre> <p>In the <code>gif_file</code> <code>Struct</code>, we can see that instead of there being a defined <code>header</code> <code>Struct</code>, we can instead just grab the <code>signature</code> and <code>version</code> as <code>Const</code> (constant) types, which functions much like the <code>magic</code> keyword in Kaitai. The only downside to doing it this way as opposed to setting a <code>Struct</code> earlier is that it will fail to parse if the version is different than the defined <code>89a</code>, instead returning an error. After those, we see: <code>\"logical_screen\" / gif_logical_screen</code>, <code>\"data\" / GreedyRange(gif_data)</code>, and an optional (commented out) <code>Const(Int8ul(\"trailer\"), 0x3B)</code>. </p> <p>Let's take a look at the <code>logical_screen</code> <code>Struct</code> which can be found at line 20 to see how it's defined in Construct:</p> <pre><code>gif_logical_screen = Struct(\n    \"width\" / Int16ul,\n    \"height\" / Int16ul,\n    \"flags\" / BitStruct(\n        \"global_color_table\" / Bit,\n        \"color_resolution\" / BitsInteger(3),\n        \"sort_flag\" / Bit,\n        \"global_color_table_bpp\" / BitsInteger(3),\n    ),\n    \"bgcolor_index\" / Int8ul,\n    \"pixel_aspect_ratio\" / Int8ul,\n    \"palette\" / If(this.flags.global_color_table,\n        Array(lambda this: 2**(this.flags.global_color_table_bpp + 1),\n            Struct(\n                \"R\" / Int8ul,\n                \"G\" / Int8ul,\n                \"B\" / Int8ul,\n            ))),\n)\n</code></pre> <p>Here we can see that <code>width</code> and <code>height</code> have the expected definitions, only selecting 2 bytes each, but <code>flags</code> is using something called a <code>BitStruct</code>. These are much like a normal <code>Struct</code>, but designed to operate on bits instead of bytes. In parsing these, the data is converted to a stream of <code>\\x01</code> and <code>\\x00</code>s (<code>1</code>s and <code>0</code>s) and then fed into the substructs. So <code>global_color_table</code> grabs just the first bit, <code>color_resolution</code> grabs the next 3 bits and parses them as an integer, etc. These values are then used in <code>palette</code> if <code>global_color_table</code> is <code>True</code> (<code>1</code>), and an <code>Array</code> is constructed with a length determined by raising 2 to the power of <code>global_color_table_bpp + 1</code> where each element in the array is another <code>Struct</code> defining the RGB values of each pixel.</p> <p>When we take a look at the next section, <code>\"data\" / GreedyRange(gif_data)</code>, we can see a bit more of how Construct utilizes its nested <code>Struct</code>. The <code>gif_data</code> <code>Struct</code> has a one byte <code>introducer</code> field which can either be read (in hex) as <code>0x21</code> or <code>0x2c</code>. That value is then read by <code>data</code> which uses a switch to either use the <code>extension</code> type or the <code>image_descriptor</code> type respectively depending on <code>introducer</code>. The extension type then has another switch which either triggers <code>application_extension</code>, <code>comment_extension</code>, <code>graphic_control_extension</code>, or the <code>plain_text_extension</code>, all of which are separately defined <code>Structs</code>. While the <code>image_descriptor</code> <code>Struct</code> is longer, it only uses bytes or BitStructs aside from its final section, <code>data_sub_block</code>.</p> <p>Now that we have some of the basics out of the way regarding describing files in Kaitai and Construct, let's try putting it all together and create a new file format to describe some data!</p>"},{"location":"filetype/","title":"3: What is a file type?","text":"<p>While it's easy to say that a <code>.jpg</code> \"is a picture\", a <code>.gif</code> \"is an animation\", or a <code>.txt</code> \"is a text document\" let's back up and think about how data is stored on a computer and translated into something that we can read and understand. </p> <p>Humans have invented what are now pretty familiar systems for interacting with computers, but it's important to remember that we interact with computers through several layers of culturally specific translations, abstractions, and conveniences that exist as barriers between our world of symbols and the laws of electromagnetism. We have spent much of the last century learning to shape metals and electricity into incredibly complex devices which we call things like \"processing units\" or \"graphics cards\". These tools can then deliver us images on demand of things that we call \"cats\", or even graphs to represent something called \"the economy\" when combined with a monitor of some kind. The point being that every file type is custom. Someone, somewhere, created a set of instructions which can be used to teach a computer program how to load a specific file format. </p> <p>A file <code>type</code> describes the extension which is used at the end of a file's name, such as <code>.jpg</code>, <code>.gif</code>, or <code>.txt</code>. The extension tells a program which <code>format</code> to use to read a given file. It is possible for different file types to share file formats, such as <code>.jpg</code> and <code>.jpeg</code>, and it is also possible for different file formats to share a file type, such as <code>.bin</code>. The <code>.bin</code> (short for binary) file type can be used to describe file formats ranging from executable binary files, game ROMs, or even CD/DVD data. File formats and file types both exist as a set of conventions rather than as strict rules. However, if you try to open an executable binary file as a game ROM, the program is likely to produce errors or simply fail to correctly interpret the data - unless the program is already prepared for either possibility.</p> <p>As file types and formats become more niche and specific to a project, it is up to developers to define their new file formats and create the software necessary to read a string of <code>1</code>s and <code>0</code>s and return something that humans can understand. </p>"},{"location":"filetype/#31-computer-language-and-number-systems","title":"3.1 Computer language and number systems","text":"<p>In some sense, a file format is a set of instructions that a program needs in order to be able to successfully open and/or save a file. Given a collection of bytes, a program will perform a set of computations to determine how to convert those bytes into a human-readable format. When considering the string of <code>1</code>s and <code>0</code>s mentioned earlier, we can ask one of the fundamental questions of computer science: How are <code>1</code>s and <code>0</code>s generated in the first place?</p> <p>Let's say you want to take some data under an existing file type, such as writing your results down in a <code>.txt</code> document. When you type a character on your keyboard, the mechanical action presses conductive material into place against a complex printed circuit laying underneath the key, allowing for a current to flow through a distinct path. This isn't necessarily true for every method of documenting characters, such as touch screens or speech-to-text, but the underlying principle is still important to note.</p> <p></p> <p><code>Woodford, Chris, (2022). Computer Keyboards</code></p> <p><code>https://www.explainthatstuff.com/computerkeyboards.html#keys</code></p> <p>The current will then enter the keyboard's microcontroller, its \"brain\", where the resulting signal is converted into a binary representation of <code>1</code>s and <code>0</code>s. However, even this familiar numerical representation is a convenient abstraction used to explain a physical system comprised of transistors and capacitors which exist inside of a computer's memory cells.</p> <p>The circuit which was completed by the key press allows for a current to flow from a power source to different systems in the computer, eventually charging a series of capacitors in its memory cells. When a capacitor is charged, we call it a <code>1</code>, and when it's discharged, we call it a <code>0</code>, representing the binary states available of charged or uncharged (this is completely thrown out of the window for quantum computing systems, but they are very much outside of the scope of this lesson). The series of charged/uncharged cells is then held and written from a specific location inside of the computer's Random Access Memory (RAM) chip until the file is saved, at which point it can be moved onto the computer's hard drive. This is true even if you save something using what has become known as \"the cloud\", a series of decentralized computers. Even on these, in order to save a file, some physical set of capacitors and transistors must be manipulated on a computer server. Normally, if you're paying for a \"cloud\" service, the servers are owned and operated by the company which you are paying, ideally with layers of encryption and security to protect your data.</p> <p>It's in this way that the typed character <code>a</code> gets translated into the binary representation <code>01100001</code>. Each character's binary representation can also be said to represent where in your keyboard's circuitry a current was and wasn't allowed to pass through specific paths. Each character one can type is thus represented by a <code>byte</code>, a number 8 digits long represented in the binary counting system. Binary is a base two counting system, meaning that one byte can represent any value between <code>00000000</code> and <code>11111111</code>, or any number between 0 and 255 when written in the familiar base ten (decimal) system.</p> <p>Ok, so what exactly is a \"base two\" counting system?</p>"},{"location":"filetype/#311-counting-in-binary-and-hexadecimals","title":"3.1.1 Counting in binary and hexadecimals","text":"<p>To understand counting systems, remember that the number system humans are used to were derived almost entirely from the fact that our species happens to have 10 fingers. As a result, we use what is called a \"base 10\" or \"decimal\" counting system. If we happened to have 8 fingers, we would instead likely use a \"base 8\" counting system. </p> <p>In base 10, the number \"3125\" could be interpreted as there being a 3 in the \"thousand\" or \\(10^3\\) place, a 1 in the \"hundred\" or \\(10^2\\) place, a 2 in the \"ten\" or \\(10^1\\) place and a 5 in the \"ones\" or \\(10^0\\) place, so: </p> \\[ 3125 = (3 \\cdot 10^3) + (1 \\cdot 10^2) + (2 \\cdot 10^1) + (5 \\cdot 10^0) \\] <p>Each new digit to the left represents an additional \\(10^n\\), where \\(n\\) is the digit's index, starting from 0. This can be continued for digits representing numbers between 0 and 1 as well, or where \\(n &lt; 0\\). Here, \\(0.1\\) can be equivalently represented as \\((1 \\cdot 10^{-1})\\), \\(0.01\\) as \\((1 \\cdot 10^{-2})\\) and so on.</p> <p>The same is true for a binary counting system, only instead of the places being determined by powers of 10, they're determined by powers of 2. Binary is pretty simplistic as such, as any 1 or 0 simply means that there is or isn't a number in that place. So <code>01100001</code> becomes: </p> \\[ (0 \\cdot 2^7) + (1 \\cdot 2^6) + (1 \\cdot 2^5) + (0 \\cdot 2^4) + (0 \\cdot 2^3) + (0 \\cdot 2^2) + (0 \\cdot 2^1) + (1 \\cdot 2^0) \\] <p>Which when represented in decimal form becomes <code>97</code>. </p> <p>Another common numerical system that one should be familiar with when working with raw data is hexadecimals. While binary shortens the number of allowed symbols per digit to only 2 (0 &amp; 1), hexadecimals is a base 16 counting system, extending the available symbols per digit from decimal's 10 (0-9) up to 16. To represent numbers larger than 9 in this system, we instead use the letters A-F, where A = 10, B = 11, ..., F = 15. </p> <p>Hexadecimal are used by software developers and the like because each hexadecimal digit can represent four <code>bits</code> (also known as a <code>nibble</code> or <code>nybble</code>), meaning that one byte can be expressed in hexadecimal using only two characters. This makes the counting system much faster to represent, as 255 can be either <code>11111111</code> when represented in binary, or <code>FF</code> in hexadecimals. The letter <code>a</code>, can now be represented as <code>01100001</code> in binary, <code>97</code> in decimal or <code>61</code> in hexadecimals, following:</p> \\[ (6 \\cdot 16^1) + (1 \\cdot 16^0) \\] <p>To summarize, when you open a text editing program and begin recording data, every new typed character appends a number between 0 and 255 to the end of your document. Inside the components of your computer, this physically translates to a group of capacitors becoming charged or discharged. Other systems of the computer can then store and retrieve the positions of those capacitors as well as their current state. Then, when you open the file in a program, the values are assigned to different characters or other graphical representations depending on the program. Each program is provided with a set of instructions to translate these values into a representation of some kind.</p> <p>So, let's talk about that set of instructions next. How does your computer take what is essentially a large number saved on your computer's memory cards and turn it into a document you can understand? How do text editors know to open a <code>.txt</code> file and represent what it reads as <code>01100001</code> as the letter <code>a</code>?</p>"},{"location":"filetype/#312-endianness","title":"3.1.2 Endianness","text":"<p>One of the first steps that a computer follows when opening a file relates to the system's <code>endianness</code>. This refers to the order that the computer will read the bytes of a given <code>word</code>, which is a fixed number of bytes, normally set by the computer's processor. There are two types of endianness: <code>big-endian</code> (BE) or <code>little-endian</code> (LE). </p> <p>Let's say that your computer defines a <code>word</code> as four bytes. We can then think of endianness like reading an english style book from left to right or a japanese one from right to left. Let's say we want to write the number <code>2024</code>:</p> <ul> <li> <p>In big-endian, the number would be written in the order: <code>2-0-2-4</code>. The most significant digit (the leftmost one) comes first, in the smallest memory address available to the computer, and the least significant digit (the rightmost one) comes last, in the largest memory address.</p> </li> <li> <p>In little-endian, this is reversed. The number would instead be written as: <code>4-2-0-2</code>, with the least significant digit being written to the smallest memory address, and the most significant digit being written to the largest memory address.</p> </li> </ul> <p>If a file is saved using one endianness but opened using another, the bytes will be misinterpreted, like trying to read a manga from left to right, or a novel starting from the last page. Many file formats will include a byte order mark (<code>BOM</code>) to indicate to the computer which endianness to use.</p>"},{"location":"filetype/#32-opening-a-file-with-a-text-editor","title":"3.2 Opening a file with a text editor","text":"<p>Plain text editors are pretty straightforward to understand. Generally, they convert all of the inputted data from binary into legible characters using encoding instructions such as the Unicode Transformation Format - 8-bit (<code>UTF-8</code>) or the American Standard Code for Information Interchange (<code>ASCII</code>). <code>UTF-8</code> is the preferred option, with 99% of average global use, but it was designed to be backwards compatible with <code>ASCII</code>, so the two systems share their first 128 characters.</p> <p>The map explaining how characters are selected from a given byte (converted into hexadecimals) looks like:</p> <p></p> <pre><code>UTF-8 Byte Map, from https://en.wikipedia.org/wiki/UTF-8#Byte_map\n</code></pre> <p>Here, the row selects the first hex character of a byte and the column selects the second. You can find <code>a</code> here in row 6, column 1. </p> <p>Since your standard text editor translates all of the information of a file through UTF-8, it's pretty useful to illustrate what data is contained in other file types. Let's see what happens when we try to use a text editor to open a file type that it wasn't designed for, such as a <code>GIF</code> file. <code>GIF</code> stands for \"Graphics Interchange Format\", and is notable for being able to represent multiple images in a single file, so the file type is often used for animations. For this example, we'll be using a gif taken from Wikipedia's article on the subject of the file type:</p> <p></p> <pre><code>Rotating_earth_(large).gif, from https://en.wikipedia.org/wiki/GIF\n</code></pre>"},{"location":"filetype/#321-text-editor-setup","title":"3.2.1 Text editor setup","text":"<p>Which text editor to use will depend on your operating system. Windows users should have access to the \"Notepad\" application, while on macOS the default text editor is called \"TextEdit\". For Linux users, your default text editor will depend on which distribution of Linux you're running. If you're unsure of which editor is available, search for \"default text editor\" + \"<code>your distribution</code>\" to find out. For Ubuntu users, the default editor is called \"Gedit\". For other distributions, common default text editors are Kate, Kwrite, and Geany.</p> <p>In general, it should be possible to simply right-click (or command-click for macOS) the file you intend to open and select the text editor that you wish to open the file with. If no text editor is available in the following drop-down menu, there should be an \"Open With\" option that will allow you to select a program to open the file. Otherwise, it is often possible to use your system's terminal to open a file, although the command for such will depend on your OS, the intended program, and the paths of the file and program. Using your terminal to open a file is generally the least efficient and straightforward method, but if it is the only one available to you, it is recommended to do an internet search for your terminal and the intended program, such as \"How to open a file in notepad using command prompt.\"</p> <p>Now that we have successfully opened a gif using a text editor file, the result should appear as a jumble of seemingly nonsensical characters, which should look something like the following in the case of the rotating globe gif.</p> <p></p> <p>You might notice in that collection of seemingly random symbols that there are still some understandable combinations of characters, such as the first 3 which spell out \"GIF\", or further down on the left side you can find \"NETSCAPE2.0\".</p> <p>A program which was designed to open that file has instructions to use all of these seemingly random bytes to assign values to the width and height of a window in which to draw the image, the number of the frames that the image will be drawn on, and the RGB color of every pixel in every frame.</p> <p>While Kaitai and Construct aren't designed to show you the final animation, they are designed to allow you to translate the raw data into something usable so that you can then load all of that information elsewhere.</p>"},{"location":"introduction/","title":"1: Introduction","text":"<p>It's common in the scientific community to record data in a custom format which might be unreadable to existing applications or programming languages. This means that in the processes of data analysis for a project, it can sometimes be necessary to create and describe a new file type and/or format. This lesson will be exploring first how to setup your computer to use the Kaitai language and Construct library before explaing how they can be used to translate one's custom binary data to make it easier to use. Kaitai can be utilized in Python, CSharp, Java, Javascript, Perl, PHP, or Ruby, while Construct is designed specifically for use with Python.  </p>"},{"location":"kaitai_basics/","title":"4: Defining the Structure in Kaitai","text":"<p>Let's try loading the GIF file in the Kaitai Web IDE to understand this better. Start by navigating to the Web IDE if you don't already have it open. </p>"},{"location":"kaitai_basics/#41-anatomy-of-the-web-ide","title":"4.1 Anatomy of the Web IDE","text":"<p>On the left side of the webpage, you'll see a list of folders, each containing pre-built <code>.ksy</code> files which you can use to test functionality. For this example, navigate to <code>formats/image/gif.ksy</code>, and double click <code>gif.ksy</code> to load it into the IDE. The buttons on the bottom left of the webpage are for creating new <code>.ksy</code> files, uploading <code>.ksy</code> or data files, and saving <code>.ksy</code> files respectively:</p> <p></p> <pre><code>New, Upload, Save\n</code></pre> <p>Click the upload button to select a <code>.gif</code> file from your computer and load it here. You should now see a webpage that looks like:</p> <p></p> <p>The viewer on the far right side should look somewhat familiar: it's the same data as when the file was opened in Notepad, now just with several of the unreadable symbols replaced with <code>.</code>s instead of Notepad's <code>\u0010</code> symbol, showing the typeable characters alongside their hexadecimal representations. </p> <p>If you click to highlight specific characters or sets of characters on either side of the <code>hex viewer</code>, the corresponding characters will be highlighted on the other side as well, allowing you to see both the hex code and UTF-8/ASCII representations for any selection. This is also true for the <code>object tree</code> section. By clicking on an item in the <code>object tree</code> underneath the <code>.ksy</code> file such as the <code>hdr</code> section, the bytes described by the section are automatically selected in the <code>hex viewer</code>. </p> <p>In the same window as the <code>hex viewer</code> are the <code>JS Code</code> and <code>JS Code (debug)</code> sections. These show how the <code>.ksy</code> file is being translated in the <code>JavaScript</code> programming language alongside a debugger.</p> <p>The <code>converter</code> section on the bottom right of the screen provides multiple different possible ways to convert selected characters. These show different methods of translating a hex code as an integer, such as <code>i8</code>, which is an 8-bit integer, <code>i16le</code> which is a 16-bit integer in <code>little endian</code> format, and so on. </p> <p>Finally, there is the <code>info panel</code> which provides information about a selection of bytes, such as the length of the selection and where in the data stream the selection is.</p> <p>If you are interested in following along more precisely with the <code>gif.ksy</code> file, there is also extensive documentation provided to describe the file format. Having documentation about the file format is crucial for describing your file type. Without documentation to follow, this process looks less like declarative programming and more like cryptography, as you would have to decipher the purpose of much of the binary data unless it happens to be written in plain text already. It's not impossible, just definitely not an ideal or efficient method.</p> <p>We won't fully describe everything being done in the example <code>.ksy</code> file here, instead we are just going to look at a broad overview to give an idea of how to use the program. Now that we know what we're looking at in the IDE, we can take a look at how the file type is being described.</p>"},{"location":"kaitai_basics/#42-meta-and-seq","title":"4.2 meta and seq","text":"<p>Your <code>.ksy</code> files should always start with a <code>meta</code> section, defining the meta-information of your file type such as the file extension (like <code>.gif</code> or <code>.tiff</code>, etc), titles, licenses, endianness (what byte-order the file should be read in), cross-references, miscellaneous documentation (like lines 17-33 of <code>gif.ksy</code>), versions, types, encodings, etc.</p> <p>The <code>seq</code> section is where the declarative work really starts. In <code>seq</code>, we can begin to describe how to handle the raw data. While it is possible to directly define streams in <code>seq</code>, it is necessary to first declare an <code>id</code> which will be the name shown in the object tree for any given attribute. You can also specify information such as a <code>type</code>, which tells the IDE what to do with the data in that section, a <code>size</code> which states the number of bytes for the object to capture, <code>content</code> can be specified for <code>magic</code> signatures, <code>encoding</code> choice can be determined here, etc.</p> <p>The <code>types</code> are then executed in the order that they're declared in <code>seq</code>, meaning that when reading the raw data of our gif, it'll apply the <code>header</code> type until its type conditions are fulfilled, then <code>logical_screen_descriptor_struct</code>, then <code>color_table</code>, and finally <code>blocks</code>. If for some reason any of the type conditions are unable to be fulfilled, the IDE will interrupt parsing and display an error message underneath the object tree.</p> <p>Instead of investigating all four different <code>types</code> in the file's <code>seq</code>, let's instead look only at the first two: <code>header</code> and <code>logical_screen_descriptor</code> to get a better idea of how Kaitai operates.</p>"},{"location":"kaitai_basics/#43-types","title":"4.3 Types","text":"<p>The <code>types</code> section is where it becomes vital to reference documentation around the file type you're trying to parse. A link to the documentation is provided in the <code>gif.ksy</code> file for the first time on line 43 for the <code>glocal_color_table</code> section, pointing the user to section 18 of the Cover Sheet for the GIF89a Specification.</p> <p>While it takes around 150 lines of code to full describe the types in <code>gif.ksy</code> (from line 48-197), longer descriptions aren't always necessary depending on the scope of your project. For instance, if you would expect the first 4 bytes to identify an object's width and height, your type could be settled quickly in the main <code>seq</code> section without ever having to create a type description, as:</p> <pre><code>seq:\n  - id: width\n    type: u2\n  - id: height\n    type: u2\n</code></pre> <p>In this example, <code>u2</code> could be replaced with <code>s1</code>, <code>s2</code>, <code>s4</code>, <code>u1</code>, <code>u2</code>, <code>u4</code>, etc, where <code>s</code> or <code>u</code> stands for signed or unsigned bytes, and the number tells the IDE how many bytes to read of that type. However, if we knew that we would later need to grab a different width and height for some reason, we could instead write this as:</p> <pre><code>seq:\n  - id: dimensions\n    type: width_and_height\n\n...\n\ntypes:\n  width_and_height:\n    seq:\n      - id: width\n        type: u2\n      - id: height\n        type: u2\n</code></pre> <p>The former method is useful for simple, straightforward data, while the latter is useful for describing repetitive data structures or for reusing types. It allows you to consolidate multiple types into a single place, to repeat types, or to use certain types in the definitions of other types.</p> <p>When looking at <code>gif.ksy</code>'s <code>header</code> type, we see:</p> <pre><code>  header:\n    doc-ref: https://www.w3.org/Graphics/GIF/spec-gif89a.txt - section 17\n    seq:\n      - id: magic\n        contents: 'GIF'\n      - id: version\n        type: str\n        size: 3\n        encoding: ASCII\n</code></pre> <p>The keyword <code>magic</code> is especially useful here as a type of safeguard, acting as a file signature when paired with the <code>contents</code> key. It simply checks that the first bytes match up with the contents, \"GIF\" in this case. The <code>magic</code> id is then followed by <code>version</code>, which simply grabs the next 3 bytes as denoted by <code>size</code> using the built in <code>str</code> (string) type, and specifies that it is using <code>ASCII</code> encoding.</p> <p>This also highlights one of the bigger strengths of Kaitai - its readability. For the most part, it's a very straightforward language. This strength is also apparent in the next type, <code>logical_screen_descriptor_struct</code>:</p> <pre><code>  logical_screen_descriptor_struct:\n    doc-ref: https://www.w3.org/Graphics/GIF/spec-gif89a.txt - section 18\n    seq:\n      - id: screen_width\n        type: u2\n      - id: screen_height\n        type: u2\n      - id: flags\n        type: u1\n      - id: bg_color_index\n        type: u1\n      - id: pixel_aspect_ratio\n        type: u1\n    instances:\n      has_color_table:\n        value: '(flags &amp; 0b10000000) != 0'\n      color_table_size:\n        value: '2 &lt;&lt; (flags &amp; 7)'\n</code></pre> <p>As you can see, it simply grabs the width and the height of the screen on which the gif will be drawn as 2 unsigned bytes, followed by three unsigned bytes that describe the <code>flags</code>, <code>bg_color_index</code>, and <code>pixel_aspect_ratio</code>. </p>"},{"location":"kaitai_basics/#431-instances","title":"4.3.1 Instances","text":"<p>After the <code>id</code>s are set in the type <code>seq</code>, we then see an <code>instances</code> section. This section is setting new variables by manipulating the previously found <code>flags</code> object using Kaitai's expression language. </p> <p><code>value: '(flags &amp; 0b10000000) !=0'</code> is doing something called \"bit masking\"; taking the bits from the <code>flag</code> byte and showing only the first one. The beginning <code>0b</code> simply means to read the <code>flags</code> object as bytes for the masking, then the <code>1</code> means the first bit is allowed through while the rest are masked with <code>0</code>, so are blocked from being read. The value is set as <code>True</code> or <code>False</code> depending on if the first bit is NOT (<code>!=</code>) equal to 0. This is a boolean operation - either the gif does or does not have a color table, which is revealed by the first bit in the <code>flags</code> byte. </p> <p>This is a good time to mention that <code>bytes</code> are not some kind of fundamental unit of computation. The choice to have 8 bits in one byte was a decision made by the International Organization for Standardization (ISO) and the International Electrotechnical Commmission (IEC) in 1993, but 6 and 9 bit bytes were common through the 1960s. Bit masking can allow for one to use every individual bit or combination of bits in a selection to correspond to a different value. In this way, one can surpass some of the artificially imposed limits on computation.</p> <p><code>color_table_size</code> is doing a similar operation but with different syntax. <code>7</code> in binary is <code>00000111</code>, so <code>(flags &amp; 7)</code> is selecting the final 3 bits. <code>2</code> in binary is <code>00000010</code> - <code>&lt;&lt;</code> is the command to shift bits to the left, so that command shifts 2 to the left by <code>flags &amp; 7</code> places. This is equivalent to raising 2 to the power of <code>1+(flags mod 8)</code> and then assigning that new value to a character.</p> <p>In our case, <code>flags</code> = 247, or <code>11110111</code>, so <code>has_color_table = True</code>, and <code>1+(flags mod 8) = 8</code>, \\(2^8 = 256\\), so <code>color_table_size = 256</code></p> <p>All of this section has been to explain, in broad strokes, some of the types as shown in the <code>GIF</code> file type. If you're interested in reading more about Kaitai Struct Language, the full documentation can be found at this link. For now, let's continue this lesson and talk about how this same file type definition can be done with the Construct library.</p>"},{"location":"putting_it_together/","title":"6: Putting it all together","text":"<p>Now that we have the basics down, let's try putting it all together. To do this, let's fabricate some data, save that data in a binary file, and then define the structure for that data in both Kaitai and Construct. After that, we can compile our formats and begin to manipulate and work with this data.</p>"},{"location":"putting_it_together/#61-creating-example-data","title":"6.1 Creating example data","text":"<p>Let's say that the data that we're taking comes as a waveform in a binary file. We can pretend that we're measuring vibrations through some material or, current intensity in some electrical system. As we're fabricating data, not actually measuring it, the justification doesn't really matter. </p> <p>For this example we'll be working in Python as it is necessary for using Construct. If you have yet to install an IDE, a link and some instructions were provided in the setup section (2.2) to install the Spyder environment.</p> <p>Let's say that for some reason we want to break our data into 3 different sections depending on the intensity. The first section can describe the entire wave form, the second can capture only some mid-range values, and the third section captures only the most intense values. </p> <p>First, we'll need to make sure that all of the necessary libraries are installed and imported. For this data, we'll need the numpy library and the struct (not Construct) library. Optionally, we can also include matplotlib in order to plot our simulated data. To check if you already have these libraries installed, open your IDE's terminal and enter:</p> <pre><code>pip list\n</code></pre> <p>This will return an alphabetical list of all modules currently installed packages/modules that your install of Python has access to, as well as their version numbers. Simply scroll through the result to see if <code>matplotlib</code>, <code>numpy</code>, and <code>python-struct</code> are installed, and if not, run:</p> <pre><code>pip install numpy\npip install matplotlib\npip install python_struct\n</code></pre> <p>You should now be free to create a new <code>.py</code> or <code>.ipynb</code> file, named something like \"example_data\". Most IDEs will require you to save the file before allowing you to run it. </p> <p>At the beginning of your new file, import the necessary modules using the commands:</p> <pre><code>import numpy as np\nimport struct\nimport matplotlib.pyplot as plt\n</code></pre> <p>Now, let's initialize 6 different arrays, one for each x and y value that is being selected from each different section.</p> <pre><code>full_x = []\nfull_y = []\n\nmid_x = []\nmid_y = []\n\npeak_x = []\npeak_y = []\n</code></pre> <p>Next, we'll want to populate these arrays with their respective data. Let's create a <code>for</code> loop which will create a wave using an equation. For this example, I'll be creating a function that is defined from <code>x=-5</code> to <code>x=5</code>, creating a y data point every increment of <code>0.0001</code> on the x axis, meaning the full data will contain 100000 points. The actual function chosen for this example doesn't matter much as long as it's possible to graph in two dimensions - you can simply plot a cosine or sin function with arbitrary limits without running into any issues (as long as your computer can handle the number of data points you create):</p> <pre><code>for i in np.arange(-5,5,0.0001):\n  # Function that is being plotted\n  n = (np.cos((2 * np.pi * i**2)/(i**2 + i))) * np.sin(i)\n\n  # Put every point in full_x and full_y\n  full_x.append(i)\n  full_y.append(n)\n\n  # Select only mid range points\n  if n**2 &lt; 0.3:\n    mid_x.append(i)\n    mid_y.append(n)\n\n  # Select only extrema\n  if n**2 &gt; 0.65:\n    peak_x.append(i)\n    peak_y.append(n)\n</code></pre> <p>You could now plot the three graphs if you wish to see what these produce by using:</p> <pre><code>plt.plot(full_x, full_y)\nplt.show()\n\nplt.plot(mid_x, mid_y)\nplt.show()\n\nplt.scatter(peak_x, peak_y, s=1)\nplt.show()\n</code></pre> <p>The resulting graphs should look like:</p> <p> </p> <p>Next, we'll want to load all of our wave data into separate numpy arrays. This allows us to set the datatype as <code>float32</code>, so each x and y value can be saved across 32 bits or 4 bytes of data. Feel free to experiment with this choice as well. You can save the data over twice as many bytes by using <code>float64</code> to double the resolution (and the filesize), or across fewer bytes using <code>float16</code> for 2 bytes or <code>float8</code> for 1 byte. You could even decide to flatten every point across integers if you wish by using <code>uint64</code>, <code>uint32</code>, and so on. Even complex numbers can be captured, with the options beginning at <code>complex64</code> and doubling until <code>complex256</code>. In any case, your arrays should look similar to:</p> <pre><code># Save data to numpy arrays\nfull_y_data = np.array(full_y, dtype=np.float32)\nfull_x_data = np.array(full_x, dtype=np.float32)\n\nmid_y_data = np.array(mid_y, dtype=np.float32)\nmid_x_data = np.array(mid_x, dtype=np.float32)\n\npeak_y_data = np.array(peak_y, dtype=np.float32)\npeak_x_data = np.array(peak_x, dtype=np.float32)\n</code></pre> <p>The next and final step of creating our example data is to write everything we've done so far to a new <code>.test</code> file. As mentioned earlier, it is very useful to include the length of each section somewhere in our final file. It's simplest to include the length at the beginning of the file, but you could also put each length before its respective section. There are other ways to manage this kind of data, but including the lengths is one of the simplest. Here's what that looks like for this data:</p> <pre><code># Save data to binary file\nwith open('wave_data.test', 'wb') as f:\n  # Write array lengths to file as integers\n  f.write(struct.pack('I', len(full_y_data)))\n  f.write(struct.pack('I', len(mid_y_data)))\n  f.write(struct.pack('I', len(peak_y_data)))\n\n  # Write each array to the file\n  full_x_data.tofile(f)\n  full_y_data.tofile(f)\n\n  mid_x_data.tofile(f)\n  mid_y_data.tofile(f)\n\n  peak_x_data.tofile(f)\n  peak_y_data.tofile(f)\n</code></pre> <p>We now have a file titled \"wave_data.test\" saved in the same directory as our python program. The file type can be decided arbitrarily - it used to be the case that type extensions were required to be 3 characters or less, but that standard has since fallen out of use.</p>"},{"location":"putting_it_together/#62-describing-the-data-in-kaitai","title":"6.2 Describing the data in Kaitai","text":"<p>Now that we have our raw binary data, we can begin working on writing the <code>.ksy</code> file which we'll be able to use later to compile our data into something useable. If you no longer have it open, navigate back to the Kaitai web IDE and create a new <code>.ksy</code> file named something like \"wave_parser.ksy\". We're going to start by describing the <code>meta</code> section. Our example is pretty simple, so we'll only need to fill out the <code>id</code>, <code>file-extension</code> and <code>endian</code> sections. </p> <p>Since we didn't explicitly define the endianness while creating our raw data file, it was written using your operating system's native endianness. If you are unsure what endianness your system uses, simply search \"(your OS) byte order.\" You could also rewrite the code generating the example data to force a specific endianness. To do that, change the lines which create the arrays from:</p> <pre><code>full_x_data = np.array(full_x, dtype=np.float32)\n.\n.\n.\n</code></pre> <p>To instead say:</p> <pre><code># For little-endian\nfull_x_data = np.array(full_x, dtype='&lt;float32') # or '&lt;f4'\n.\n.\n.\n\n# For big-endian\nfull_x_data = np.array(full_x, dtype='&gt;float32') # or '&gt;f4'\n.\n.\n.\n</code></pre> <p>Now in our <code>meta</code> section, let's add:</p> <pre><code>meta:\n  id: test\n  file-extension: test\n  endian: le # or be\n</code></pre> <p>When creating our file, we used the line <code>f.write(struct.pack('I', len(full_data)))</code> to add the size of each section to the beginning of the file. In this line <code>I</code> stands for an unsigned 4-byte integer. In Kaitai, this is captured by <code>type: u4</code>, so we define a <code>type</code> called <code>full_mid_peak_lens</code> which grabs <code>full_len</code>, <code>mid_len</code>, and <code>peak_len</code> as <code>u4</code>s so that they can be used elsewhere.</p> <pre><code>types:\n  full_mid_peak_lens:\n    seq:\n      - id: full_len\n        type: u4\n      - id: mid_len\n        type: u4\n      - id: peak_len\n        type: u4\n</code></pre> <p>Now we can go above the <code>types</code> section to the main <code>seq</code> and create an object to store these lengths so that we can retrieve them later:</p> <pre><code>seq:\n  - id: lengths\n    type: full_mid_peak_lens\n</code></pre> <p>Next, we can use the <code>length</code> object to select arrays which are the length of each respective section of the data. It's important to remember here what choice was made to define the size of each data point. As I went with <code>float32</code>, each data point will be saved as a float valued <code>f4</code> type. Kaitai has the options of <code>f1</code>, <code>f2</code>, <code>f4</code>, and <code>f8</code>, (or <code>u1</code>, <code>s1</code>, etc) each specifying how many bytes they capture. To capture the <code>full_data</code> section, let's move back to the <code>types</code> section and continue:</p> <pre><code>  full_data:\n    seq:\n      - id: x_data\n        type: f4\n        repeat: expr\n        repeat-expr: _root.lengths.full_len\n\n      - id: y_data\n        type: f4\n        repeat: expr\n        repeat-expr: _root.lengths.full_len\n</code></pre> <p>Now we can simply repeat this step for each of the sections, creating the <code>mid_data</code> and <code>peak_data</code> types before returning above the <code>type</code> section once more to the main <code>seq</code>. From there, all we have to do is create a new object for each of these types to use, which should look something like:</p> <pre><code>  - id: f_data\n    type: full_data\n\n  - id: m_data\n    type: mid_data\n\n  - id: p_data\n    type: peak_data\n</code></pre> <p>And just like that, we've described our first file format using Kaitai! Make sure to save your file, and we can learn how to use our <code>.ksy</code> file to rebuild our raw data.</p>"},{"location":"putting_it_together/#63-parsing-raw-data-with-a-ksy-file","title":"6.3 Parsing raw data with a .ksy file","text":"<p>It was mentioned in the page for our setup that advanced users may wish to install <code>ksc</code> for further work. Doing this install now would be necessary in order to continue, so if you have not yet followed the instructions in the advanced section, please do so to continue. </p> <p>TODO: WSL Installation instructions</p> <p>To get started, you'll need to know the path to your .ksy file and to the folder generated by your install of <code>ksc</code>. Then, you'll want to navigate to the generated folder using WSL.</p> <pre><code>cd /path/to/kaitai_struct_awkward_runtime\n</code></pre> <p>Next, you'll generate the source and header files for your target language.</p> <pre><code>ksc -t &lt;language&gt; --outdir &lt;new_foldername&gt; &lt;path/to/your/file.ksy&gt;\n</code></pre> <p>Replacing the parts in brackets accordingly. For <code>language</code>, the options are: <code>cpp_stl</code>, <code>csharp</code>, <code>java</code>, <code>javascript</code>, <code>perl</code>, <code>php</code>, <code>python</code>, <code>ruby</code>, or <code>all</code></p> <p>For <code>new_foldername</code>, the new folder will be created inside the <code>kaitai-struct-awkward-runtime</code> folder. After running the above commands, you should have generated a new folder and file. If your target (<code>-t</code>) language was python, the generated file will appear as <code>&lt;extension&gt;.py</code>. In my case, we now have the folder <code>wave_test</code> which contains <code>test.py</code>, so we can finally put this all together.</p> <p>You can either create a new python or notebook file at the same level as your <code>wave_test</code> folder or equivalent, move/copy that folder where you want to make your parsing file, or keep the folders seperate and start your new file by running:</p> <pre><code>import sys\n</code></pre> <p>before using <code>sys.path.append()</code> to point to the respective folder. Having the folder on the same hierarchy as your new file will avoid this extra step however. Now, we'll want to import everything from our generated file, import <code>Path</code> in order to use the raw file, and <code>matplotlib.pyplot</code> in order to plot it:</p> <pre><code>from pathlib import Path\nfrom wave_test.test import * # replace wave_test with your folder name\nimport matplotlib.pyplot as plt\n</code></pre> <p>We are now able to load our data file in and begin parsing it. Let's first load our raw data before parsing it as the generated <code>Test</code> class. If you didn't use the same <code>id</code> as in the example, open the generated <code>.py</code> file and use the highest level <code>class</code> - it should match the <code>id</code> from your <code>meta</code> section.</p> <pre><code>raw_data = Path('wave_data.test')\nwave_data = Test.from_file(raw_data)\n</code></pre> <p>From here, the different types and their subtypes can be accessed directly as attributes, so we can print out each of the lengths using:</p> <pre><code>f_length = wave_data.lengths.full_len\nm_length = wave_data.lengths.mid_len\np_length = wave_data.lengths.peak_len\nprint(f_length, m_length, p_length)\n</code></pre> <p>We can also access the wave data the same way:</p> <pre><code>full_x = wave_data.f_data.x_data\nfull_y = wave_data.f_data.y_data\nplt.plot(full_x, full_y)\n</code></pre> <p>This can be repeated for the <code>mid</code> and <code>peak</code> data as well using <code>m_data</code> and <code>p_data</code> respectively. And with that, we have officially learned how to use a <code>.ksy</code> file to parse raw data! Let's move on to doing the same with Construct definitions.</p>"},{"location":"putting_it_together/#64-describing-the-data-in-construct","title":"6.4 Describing the data in Construct","text":"<p>If for some reason it's useful for your project to create a description of your file format using both Kaitai and Construct, I'd recommend first creating a Kaitai description and then basing your Construct file off of it, simply because the syntax for Kaitai is more straightforward. With that being said, let's open up a new <code>.py</code> or <code>.ipynb</code> file and begin by importing the Construct module, matplotlib.pyplot, and numpy before defining our Structs. </p> <pre><code>from construct import *\nimport matplotlib.pyplot as plt\nimport numpy as np\n</code></pre> <p>Next, as before, we'll want to capture the three numbers at the front of the file which tell us how long each array is. Our approach here will look much like our Kaitai work, but there are still multiple different ways to perform this capture, and experimenting to see what feels most efficient for you is definitely encouraged.</p> <p>For this example, I'm going to start off with what will eventually be the final Struct and create a sub Struct which will use the values captured here.</p> <pre><code>test_struct = Struct(\n  \"lengths\" / Struct(\n    \"full_data_len\" / Int32ul,\n    \"mid_data_len\" / Int32ul,\n    \"peak_data_len\" / Int32ul\n  )\n)\n</code></pre> <p>As mentioned previously, this Struct will come last. This is a limitation of Python more than of Construct, as Python is unable to use variables or Structs that have yet to be declared. But since the Struct that comes before this one will only be used when it's later nested into <code>test_struct</code>, we'll be able to reference the <code>lengths</code> sub-Struct to capture the full, mid, and peak data lengths. Each of the data sections will select 4 bytes at a time and save them into an array of the stated length.</p> <pre><code>data_sections = Struct(\n    \"full_x_data\" / Array(\n        this._root.lengths.full_data_len,\n        Float32l\n    ),\n    \"full_y_data\" / Array(\n        this._root.lengths.full_data_len,\n        Float32l\n    ),\n\n    \"mid_x_data\" / Array(\n        this._root.lengths.mid_data_len,\n        Float32l\n    ),\n    \"mid_y_data\" / Array(\n        this._root.lengths.mid_data_len,\n        Float32l\n    ),\n\n    \"peak_x_data\" / Array(\n        this._root.lengths.peak_data_len,\n        Float32l\n    ),\n    \"peak_y_data\" / Array(\n        this._root.lengths.peak_data_len,\n        Float32l\n    ),\n)\n</code></pre> <p>Now we can simply add this Struct into <code>test_struct</code> as:</p> <pre><code>test_struct = Struct(\n    \"lengths\" / Struct(\n        \"full_data_len\" / Int32ul,\n        \"mid_data_len\" / Int32ul,\n        \"peak_data_len\" / Int32ul\n    ),\n    \"data_sects\" / data_sections\n)\n</code></pre> <p>For selections that only have one defining Struct, like <code>data_sects</code>, there isn't necessarily a reason not to also name the sub Struct (<code>data_sects</code>) after the Struct that it's using (<code>data_sections</code>). In this case, it's simply a matter of shortening the name to reduce how much typing is necessary to call that attribute later. It's not uncommon to have a Struct with a very clear name which is then given a shortened name in the Struct that actually uses it. Remember when doing this that only the quoted name will be useable. If You try to reference <code>data_sections</code> instead of <code>data_sects</code>, you'll end up with a <code>KeyError</code>.</p>"},{"location":"putting_it_together/#65-parsing-raw-data-using-construct","title":"6.5 Parsing raw data using Construct","text":"<p>This process is much simpler than with Kaitai - you can do all of the work from the same file as where you set the Structs. Let's now just create a function that parses our file and then plots the results:</p> <pre><code>def parse_file(input_path):\n  with open(input_path, 'rb') as input_f: # 'rb' ='read binary'\n    raw_data = input_f.read()\n    parsed_data = test_struct.parse(raw_data)\n\n    # Select all relevant values\n    full_x_data = parsed_data.data_sects.full_x_data\n    full_y_data = parsed_data.data_sects.full_y_data\n\n    mid_x_data = parsed_data.data_sects.mid_x_data\n    mid_y_data = parsed_data.data_sects.mid_y_data\n\n    peak_x_data = parsed_data.data_sects.peak_x_data\n    peak_y_data = parsed_data.data_sects.peak_y_data\n\n    # Plot all data\n    plt.plot(full_x_data, full_y_data)\n    plt.plot()\n    plt.show()\n\n    plt.scatter(mid_x_data, mid_y_data, s=1)\n    plt.plot()\n    plt.show()\n\n    plt.scatter(peak_x_data, peak_y_data, s=1)\n    plt.plot()\n    plt.show()\n</code></pre> <p>Now all that's left is to call our <code>parse_file</code> function:</p> <pre><code>input_path = &lt;/your/path/to/wave_data.test&gt;\nparse_file(input_path)\n</code></pre> <p>And you have officially parsed your first file using Construct!</p>"},{"location":"setup/","title":"2: Setup","text":"<p>Installation isn't strictly necessary for working with Kaitai, but is required for working with Construct. </p>"},{"location":"setup/#21-kaitai-ide","title":"2.1 Kaitai IDE","text":"<p>For Kaitai, the Web IDE (Integrated Development Environment) is the simplest way to get started, and is all that is necessary for the majority of this lesson. If you're already familiar with the language you can use the Web IDE to jump straight in to describing your data format. If you're not familiar, it's recommended to read through the existing documentation. The instructions in section 4. Defining the Structure in Kaitai reference the documentation enough to describe one file type, but the actual documentation provides a much more complete description of Kaitai's syntax and its available commands. Advanced users may wish to install <code>ksc</code>, the <code>kaitai-struct-compiler</code>, and/or <code>ksv</code>, the <code>kaitai-struct-visualizer</code>, directly onto their own machine. Instructions to do so are included in the Advanced section.</p>"},{"location":"setup/#22-python-setup","title":"2.2 Python Setup","text":"<p>In order to use Construct, it is necessary to have Python installed on your machine. If that is already the case for you and you are already familiar with an IDE of your choice, this section can be skipped.</p> <p>There are numerous IDEs with which one can use for programming in Python: Spyder, Anaconda, Visual Studio Code, and Pycharm are popular choices, just to name a few. For this lesson, it is recommended to install and familiarize yourself with the Spyder environment, which can be downloaded and installed from here. Spyder is an open-source program which was built in Python, for Python, specifically for use in data science. </p> <p>By following the link, you should have the option to download the IDE for your operating system (Windows, macOS, and Linux are supported), at which point you can follow the guided installation. The IDE should open after the installation is complete, at which point it is recommended to follow along with the tour for a quick overview of the IDE.</p>"},{"location":"setup/#23-construct-setup","title":"2.3 Construct Setup","text":"<p>After installing the Python IDE of your choice, open or navigate to the console. In Spyder, the console is found as the window on the bottom right (by default), and should resemble the below image.</p> <p></p> <p>If you're having trouble finding the console, or have removed the window by accident (or on purpose and are unsure how to return it), it should be possible to turn it back on by navigating to <code>View</code> &gt; <code>Panes</code> &gt; and checking the box next to <code>IPython Console</code>. Alternatively on Windows, you can also type <code>CTRL+SHIFT+I</code> to open or close the console window.</p> <p>Construct doesn't have any hard dependencies, but all supported modules can be installed as well with a single command. The basic version of Construct is enough for this lesson. To install it, you should only need to type or copy the following into the console and hit enter:</p> <pre><code>pip install construct\n</code></pre> <p>Advanced users can refer to the advanced section for further instructions.</p>"}]}