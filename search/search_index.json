{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>In scientific computing, data is often stored in custom binary formats. These formats might be tailored for specific instruments, simulations, or to optimize for storage space or read/write speed. However, a major drawback is that standard analysis software and programming language libraries usually cannot interpret these specialized binary structures directly.</p> <p>This lack of interoperability creates a hurdle: before the data can be analyzed or shared effectively, its binary layout must be explicitly defined and parsed. This lesson addresses this common challenge. We will explore how to set up and use two powerful tools:</p> <ol> <li>Kaitai Struct: A YAML based declarative language for describing binary data structures, which can generate parser code in various languages (Python, C#, Java, JavaScript, Perl, PHP, Ruby).</li> <li>Construct: A Python library for parsing and building binary data structures.</li> </ol> <p>We will guide you through installing these tools and then show you how to use them in your analysis workflow.</p> <p>If you are new to programming, it's recommended that you first take a few minutes to go over this short lesson talking about how to read technical documentation.</p> <p>Continue to Setup to get your environment ready.</p>"},{"location":"01_setup/","title":"Setup","text":"<p>This section will guide you through setting up the tools needed for this lesson: the Kaitai Web IDE (for describing binary formats) and the Construct Python library (for parsing them in Python). By the end, you'll be ready to follow along with all code examples.</p>"},{"location":"01_setup/#kaitai-ide","title":"Kaitai IDE","text":"<p>No installation is required for most users. Simply open the Kaitai Web IDE in your browser. - To get started:   1. Go to https://ide.kaitai.io/   2. Click \"New\" to create a new .ksy file   3. Follow the instructions in Section 3: Defining the Structure in Kaitai</p> <p>Advanced users: If you want to use Kaitai offline or generate parsers locally, see the appendix for installing <code>ksc</code>, the <code>kaitai struct compiler</code>, and <code>ksv</code>, the <code>kaitai struct visualizer</code>. Installing <code>ksc</code> will be required to complete the Kaitai portion of this lesson.</p>"},{"location":"01_setup/#python-and-ide-setup","title":"Python and IDE Setup","text":"<p>To use Construct, you need Python 3.6 or newer.  </p> <ul> <li> <p>Download Python from python.org if you don't have it.</p> </li> <li> <p>Check your Python version:</p> </li> </ul> <pre><code>python --version\n</code></pre> <p>We recommend using a Python virtual environment to keep your dependencies isolated. To set up a virtual environment using <code>virtualenv</code>:</p> <ol> <li>Install <code>virtualenv</code> if you don't have it:     <code>bash     pip install --user virtualenv</code></li> <li>Create a new environment (replace <code>env</code> with your preferred name):     <code>bash     python -m virtualenv env</code></li> <li>Activate the environment:<ul> <li>On Linux/macOS:     <code>bash     source env/bin/activate</code></li> <li>On Windows:     <code>bash     .\\env\\Scripts\\activate</code></li> </ul> </li> </ol> <p>You can use any IDE (e.g., VS Code, PyCharm, Anaconda), but we recommend Spyder for beginners.</p>"},{"location":"01_setup/#construct-setup","title":"Construct Setup","text":"<p>With your virtual environment activated, install Construct:</p> <pre><code>pip install construct\n</code></pre> <p>If you encounter installation issues, refer to the Appendix or consult the official documentation for Construct.</p> <p>Continue to File types and formats to learn how computers interpret and store different file types.</p>"},{"location":"02_files/","title":"What Makes a File","text":"<p>As we're about to begin exploring the mechanics of hardware and software on a more fundamental level than the average computer or phone user might be used to, it's important to remember that we are navigating culturally specific conventions and abstractions that have been built up over several decades. After nearly a century of refining our processes and methods, we now have access to almost unthinkably complex devices which we call things like \"Graphics Processing Units\" (GPUs), or \"Random Access Memory\" (RAM) cards, which can work together in a device small enough to fit into your pocket and is capable of delivering you pictures of cats from around the world. </p> <p>So, when we say a <code>.jpg</code> file \"is a picture\", a <code>.gif</code> file \"is an animation\", or a <code>.txt</code> file \"is a text document\", we're relying on conventions that help computers and humans organize and interpret data. But how does a computer actually know what to do with a file? Let's step back and explore how data is stored, and how we've managed to trick silicon and copper into turning electrons into something humans can understand and interact with.</p> <p>Files often have an extension at the end of their name (such as <code>.jpg</code>, <code>.gif</code>, or <code>.txt</code>). This extension suggests to programs which format the actual structure and encoding of the data is organized in so that the program can effectively read the file.</p> <p>Sometimes, the same file format can have multiple extensions (e.g., <code>.jpg</code> and <code>.jpeg</code>), and sometimes a single file extension can refer to many different formats (e.g., <code>.bin</code> for binary data). These conventions are not strict rules. If you try to open a file with the wrong program, the data may be misinterpreted or unreadable. </p> <p>As new needs arise, developers create new file formats to meet emerging needs, along with software that can interpret the underlying binary data and display it in a human-readable form. For example, word processors like Microsoft Word use the <code>.docx</code> format to save documents, which encodes text, formatting, and metadata in a structured way. While formats like this are essential for organizing data, most modern systems are designed to hide details about file formats from the user. When you take a photo on your phone and upload it to social media, you don't usually need to know whether or not the image is saved as a <code>.jpg</code>, <code>.png</code>, or <code>.tiff</code>\u2014software handles those details for you. </p> <p>Click here to continue to the next section where we will go over how computers are designed to represent and interpret data.</p>"},{"location":"03_representation/","title":"Representing Files on a Computer","text":"<p>In order for your computer to represent raw data in any form, it has to use certain software. Software contains a set of instructions that a computer can use to open, edit, and/or save files. A file formats acts like a contract: it defines how the data is organized in storage so that the compatible software can understand and work with it. In this section, we're going to go over how computers store data in binary, and how that binary data can be translated into other forms such as hexadecimals or represented graphically using ASCII or UTF-8. But first, let's quickly go over what we're talking about when we we're talking about storing and accessing data.</p>"},{"location":"03_representation/#storage","title":"Storage","text":"<p>We're using the term \"computer\" in this lesson to refer to many types of modern devices such as laptops, PCs, phones, tablets, server towers, and the like. To simplify (a lot), computers save data using bits, which are commonly represented as a series of <code>1</code>s and <code>0</code>s. This shorthand is used to refer to physical states inside of the primary data storage, though the way those bits are physically stored depends on the type of device. This can range from using the North/South orientation of magnetic dipoles in hard disk drives (HDDs) and magnetic tapes (such as VHS and cassettes), the charged/uncharged state of transistors and capacitors in solid state drives (SSDs) or memory cards, or pits and lands on optical disks (such as CDs, DVDs, and Blu-Ray). Each of these physical bits is also assigned a numerical bit address. The read/write component uses these addresses to locate specific bits, check their state, or change them.</p> <p>Regardless of the physical medium, whether it's magnetic, electronic, or optical, data storage ultimately comes down to maintaining and detecting two distinct binary states. Something or nothing, charged or uncharged, north or south. The read/write component interprets those states and delivers the information to other parts of the computer. </p>"},{"location":"03_representation/#computer-language-and-number-systems","title":"Computer Language and Number Systems","text":"<p>Now that we have a rudimentary understanding of how binary data is stored, we should ask: how can such simple binary states represent so much complexity?</p> <p>The human computer scene in Netflix's The Three-Body Problem offers a useful visualization of this. In the scene, each soldier acts as a single bit, holding a two sided sign where the white side represents a <code>0</code> and the black side represents a <code>1</code>. Their individual states are simple, but together they form a functioning computer by reacting to their neighbors and following simple rules.</p> <p>If this video isn't working for you, you may have to open it in another page. Click here to open the video on YouTube. </p> <p>In this scene, the different segments of soldiers can be thought of as comprising different components of a computer. </p> <p>In the book by Cixin Liu, the orders that the flag-holding soldiers receive are described in terms of logic gates (AND, OR, NOT, etc):</p> <p>Newton took out six small flags: three white, three black. Von Neumann handed them out to the three soldiers so that each held a black flag and a white flag. \"White represents 0; black represents 1. Good. Now, listen to me. Output, you turn around and look at Input 1 and Input 2. If they both raise black flags, you raise a black flag as well. Under all other circumstances, you raise the white flag.\"     </p> <p>Thus forming an AND gate, where both Inputs 1 AND Input 2 must raise a black flag for output to do the same. (If you're interested in learning more about boolean logic and logic gates, this episode of CrashCourse is a great starting point.) When these gates are arranged in specific sequences, more complex operations such as arithmetic, data storage, and anything else that you can do on a computer can be performed. It's in this way that anything that can represent two binary states can act as different components of a computer.</p> <p>Von Neumann pointed to the gigantic human circuit below the pyramid and began to explain, \"Your Imperial Majesty, we have named the computer Qin I. Look, there in the center is the CPU, the core computing component, formed from your five best divisions. [...] Observe also the open passage that runs through the entire formation, and the light cavalry waiting for orders in that passage: That's the system bus, responsible for transmitting information between the components of the whole system.</p> <p>(As some context for those who haven't seen the show or read the book, the characters Newton and Von Neumann are humans inside a virtual reality game created by an advanced alien civilization. When they first enter it, they are prompted to choose a new name, and they opt for the names of famous scientists.)</p> <p>While humans flipping signs definitely isn't the most efficient method of computation, it does demonstrate how the fundamentals of computing can be structured to deliver complex information.</p>"},{"location":"03_representation/#counting-in-binary","title":"Counting in Binary","text":"<p>As a side effect of finding ourselves with 10 fingers (usually), humans have developed a base 10 (decimal) numerical system. In base 10, the number \"3125.0\" can be thought of as:</p> \\[ (3 \\cdot 10^3) + (1 \\cdot 10^2) + (2 \\cdot 10^1) + (5 \\cdot 10^0) + (0 \\cdot 10^{-1}) \\] <p>Each new digit to the left of the decimal point represents an additional \\(10^n\\), where \\(n\\) is the digit's index, starting from 0, while each digit to the right of the decimal point represents an additional \\(10^{-n}\\). So 3125.0 has a 3 in the \"thousand\" or \\(10^3\\) place, a 1 in the \"hundred\" or \\(10^2\\) place, a 2 in the \"ten\" or \\(10^1\\) place, a 5 in the \"one\" or \\(10^0\\) place, and a 0 in the tenth or $10^{-1} place.</p> <p>Binary works the same way, but with powers of 2 instead of 10. </p> <p></p> <p>GIF from https://blog.adafruit.com/2018/09/10/analog-binary-counter-visually-demonstrates-0-to-63-in-base-10-video/</p> <p>When you type a character in a <code>.txt</code> document, your device interprets that as a signal that is then converted into a sequence of bits. For example, the character a becomes the binary <code>01100001</code>.</p> <p>Each character that can be typed can also be represented in a single byte (8 bits). This means that one 8-bit byte can represent any value from <code>00000000</code> to <code>11111111</code> (0 to 255 in decimal). </p> <p>So, <code>01100001</code> in binary can be represented like:</p> \\[ (0 \\cdot 2^7) + (1 \\cdot 2^6) + (1 \\cdot 2^5) + (0 \\cdot 2^4) + (0 \\cdot 2^3) + (0 \\cdot 2^2) + (0 \\cdot 2^1) + (1 \\cdot 2^0) \\] <p>Or 97 in decimal form.</p>"},{"location":"03_representation/#counting-in-hexadecimal","title":"Counting in Hexadecimal","text":"<p>Hexadecimal numbers (base 16) are often used as a compact way to represent binary values. The numbers 0-9 are represented by their familiar decimal symbols, while the letters A-F are used to represent numbers up to 15 (A=10, B=11, ..., F=15). As \\(16=2^4\\), each hexadecimal digit can be used to represent half a byte (the technical term is a \"nibble\". Yes, really.). So one byte can be expressed using only two characters in hexadecimal. This makes the hexadecimal counting system much more compact in its ability to represent data. In this way, <code>a</code> can be represented in hex form as <code>61</code>.</p> <p>\\((6 \\cdot 16^1) + (1 \\cdot 16^0)\\) = 97 (decimal) = 01100001 (binary)</p> <p>To summarize: when you type a character, a series of 8 bits are flipped somewhere in your systems memory to represent a number between 0 and 255. Programs can then use software to translate these values into something meaningful.</p> <p>So, how does your computer take a large number saved in memory and turn it into a document you can understand? How do text editors know to open a <code>.txt</code> file and represent the series of bits <code>01100001</code> as the letter <code>a</code>?</p>"},{"location":"03_representation/#endianness","title":"Endianness","text":"<p>One of the first things a program may need to check when reading binary data is its endianness, or the order in which bytes of a given word (a fixed number of bytes set by the computer's processor) are to be read. There are two types:</p> <ul> <li>Big-endian (BE): The most significant byte (the one with the highest value place) comes first.</li> <li>Little-endian (LE): The least significant byte (the one with the lowest value place) comes first.</li> </ul> <p>Suppose a word is four bytes, and you want to write the number <code>2024</code>:</p> Endianness Byte Order (hex) Big-endian 00 00 07 E8 Little-endian E8 07 00 00 <p>If a file is saved using one endianness but opened using another, the bytes will be misinterpreted. Think of it as similar to trying to read a manga from left to right, or a novel starting from the last page. Many file formats include a byte order mark (BOM) to indicate which endianness to use.</p>"},{"location":"03_representation/#opening-a-file-with-a-text-editor","title":"Opening a file with a text editor","text":"<p>Plain text editors convert binary data into legible characters using encodings such as UTF-8 or ASCII. UTF-8 is the most widely used encoding and is backwards compatible with ASCII for the first 128 characters.</p> <p>The following table shows how each byte value maps to a character in UTF-8:</p> <p> UTF-8 Byte Map, from Wikipedia</p> <p>In this table, the row selects the first hex character of a byte and the column selects the second. For example, the letter <code>a</code> (hex <code>61</code>) is found at row 6, column 1.</p> <p>This table helps explain why some bytes in a binary file appear as readable characters when opened in a text editor.</p> <p>Text editors work well for text files, but what happens if you open file that a text editor wasn't designed for, like a GIF? Let's test it out by using this GIF file from Wikipedia:</p> <p></p> <p>Rotating_earth_(large).gif, from Wikipedia</p>"},{"location":"03_representation/#text-editor-setup","title":"Text editor setup","text":"<p>Which text editor to use depends on your operating system:</p> <ul> <li>Windows: Notepad</li> <li>macOS: TextEdit</li> <li>Ubuntu/Linux: Gedit (others: Kate, Kwrite, Geany, etc.)</li> </ul> <p>You can usually right-click (or command-click on macOS) a file and select \"Open With\" to choose your text editor. If you need to use the terminal, search for instructions specific to your OS and editor (e.g., \"How to open a file in Notepad using Command Prompt\").</p> <p>Now, open the GIF file in your text editor. The result should appear as a jumble of seemingly nonsensical characters, such as:</p> <p></p> <p>Notice that among the symbols, some readable text appears\u2014such as \"GIF\" at the start (the file signature) and \"NETSCAPE2.0\" further down. These are parts of the file format specification that are stored as plain text within the binary data. Some of the binary content is mapped to readable characters because it corresponds to standard ASCII values, while the rest appears garbled or empty because it's either non-text data or outside the displayable character range.</p> <p>A program designed to open a GIF file uses all of these bytes to determine properties like image width, height, frame count, and pixel colors.</p> <p>While tools like Kaitai and Construct don't display the animation directly, they allow you to parse and interpret the raw data, making it possible to extract and use this information in your own programs.</p> <p>Continue to Kaitai basics to start describing file formats declaratively.</p>"},{"location":"04_kaitai_basics/","title":"Defining the Structure in Kaitai","text":"<p>Let's try loading the GIF file in the Kaitai Web IDE to understand this better. Start by navigating to the Kaitai Web IDE if you don't already have it open.</p>"},{"location":"04_kaitai_basics/#anatomy-of-the-web-ide","title":"Anatomy of the Web IDE","text":"<p>This image shows the IDE with the loaded <code>gif.ksy</code> and the example <code>Rotating_earth_(large).gif</code> files. Let's use them to quickly go over each section of the Kaitai IDE.</p> <p>On the left side of the webpage (1), you'll see a list of folders and files. The IDE contains several pre-built <code>.ksy</code> files which you can use to test functionality or explore to learn more about Kaitai and its uses. To load the same example file, navigate to <code>formats/image</code> and double-click <code>gif.ksy</code> to load it into the IDE. The buttons on the bottom left of the webpage (underneath section 1) are for creating new <code>.ksy</code> files, uploading <code>.ksy</code> or data files, and saving <code>.ksy</code> files:</p> <p></p> <pre><code>New | Upload | Save\n</code></pre> <p>Click the upload button to select a <code>.gif</code> file from your computer and load it here. Your webpage should now look like the one in the labelled image. The <code>gif.ksy</code> file's contents are loaded in section 2.</p> <p>Selecting characters in the object tree (3), or either of the two right sections of the hex viewer (5 or 6) will highlight the corresponding characters in all three, allowing you to see the hex code, UTF-8/ASCII representations, and the declared <code>type</code> for any selection.</p> <p>The viewer on the far right side (6) should look somewhat familiar: it's the same data as when the file was opened in a text editor, but with the unreadable symbols replaced with <code>.</code>s, showing the typeable characters alongside their hexadecimal representations to the left (5).</p> <p>The byte addresses are shown in section 4, the offset column, which shows the addresses of the first byte in each row of the file. These offsets can help you locate where each group of 16 bytes begins in the overall file. The row labeled <code>00000010</code> corresponds to bytes <code>0x10</code> to <code>0x1F</code>. These offsets are useful for navigating large files and for matching parsed structures to their exact position in the binary data.</p> <p>Then there is the <code>info panel</code> (7), which provides information about a selection of bytes, such as the length of the selection and where in the data stream the selection is.</p> <p>Finally, the <code>converter</code> section (8) provides multiple ways to interpret selected characters, showing different methods of translating a hex code (e.g., <code>i8</code> for an 8-bit integer, <code>i16le</code> for a 16-bit integer in little-endian format, etc.).</p> <p>If you are interested in following along more precisely with the <code>gif.ksy</code> file, there is also extensive documentation provided to describe the file format. Having documentation about the file format is crucial for describing your file type. Without documentation to follow, this process looks less like declarative programming and more like cryptography, as you would have to decipher and assume/assert the purposes of much of the data unless it happens to be written in plain text already.</p> <p>We won't fully describe everything being done in the example <code>.ksy</code> file here. Instead, we'll look at a broad overview to give an idea of Kaitai's functionality. Now that we know what we're looking at in the IDE, we can take a look at how the file type is being described.</p>"},{"location":"04_kaitai_basics/#meta-and-seq","title":"<code>meta</code> and <code>seq</code>","text":"<p><code>.ksy</code> files should always start with a <code>meta</code> section, defining meta-information about your file type such as the file extension (like <code>gif</code> or <code>tiff</code>), title, license, endianness, cross-references, documentation, version, types, and encodings.</p> <p>The <code>seq</code> section is where the declarative work really starts. In <code>seq</code>, you describe how to handle the raw data. Each entry in <code>seq</code> must declare an <code>id</code> (the name shown in the object tree for that attribute). You can also specify a <code>type</code> (giving more instructions on how to interpret the data), a <code>size</code> (number of bytes to capture), <code>contents</code> (for magic signatures), <code>encoding</code>, and more.</p> <p>When reading the raw data of our GIF, Kaitai will apply each type in the order that it appears in <code>seq</code>. So it will first fit data to the <code>header</code> type until its conditions are fulfilled, then the <code>logical_screen_descriptor_struct</code> type, then <code>color_table</code> type, and finally the <code>blocks</code> type. If any type conditions are not fulfilled, the IDE will interrupt parsing and display an error message underneath the object tree.</p> <p>Instead of investigating all four different <code>types</code> in the file's <code>seq</code>, let's look only at the first two: <code>header</code> and <code>logical_screen_descriptor</code>, to learn the basics of using Kaitai.</p>"},{"location":"04_kaitai_basics/#types","title":"Types","text":"<p>The <code>types</code> section is where it becomes vital to reference documentation about the file type you're trying to parse. For example, the <code>gif.ksy</code> file links to the GIF89a Specification.</p> <p>While it takes around 150 lines of code to fully describe the types in <code>gif.ksy</code>, longer descriptions aren't always necessary depending on your project's scope. For instance, if you expect the first 4 bytes to identify an object's width and height, your type could be settled quickly in the main <code>seq</code> section without having to create a type description:</p> <pre><code>seq:\n  - id: width\n    type: u2\n  - id: height\n    type: u2\n</code></pre> <p>In this example, <code>u2</code> could be replaced with <code>s1</code>, <code>s2</code>, <code>s4</code>, <code>u1</code>, <code>u2</code>, <code>u4</code>, etc., where <code>s</code> or <code>u</code> stands for signed or unsigned bytes, and the number tells the IDE how many bytes to read of that type.</p> Quick aside: Signed vs. Unsigned Bytes <p>    A **signed** number can be positive *or* negative, while an **unsigned** number can only be positive. This matters when interpreting binary data: for example, a 1-byte unsigned value (`u1`) can represent values from `0` to `255`, while a signed 1-byte value (`s1`) can represent values from `-128` to `127`. The total number of values is the same. What changes is the range and how the binary pattern is interpreted.   </p> <p>However, if you know you'll need to grab a different width and height multiple times for some reason, you could instead write this as:</p> <pre><code>seq:\n  - id: dimensions\n    type: width_and_height\n  - id: other_data\n  [...]\n  - id: second_dimensions\n    type: width_and_height\n\ntypes:\n  width_and_height:\n    seq:\n      - id: width\n        type: u2\n      - id: height\n        type: u2\n</code></pre> <p>The former method is useful for simple, straightforward data, while the latter is useful for describing repetitive data structures or for reusing types. It allows you to consolidate multiple types into a single place, to repeat types, or to use certain types in the definitions of other types.</p> <p>When looking at <code>gif.ksy</code>'s <code>header</code> type, we see:</p> <pre><code>header:\n  doc-ref: https://www.w3.org/Graphics/GIF/spec-gif89a.txt - section 17\n  seq:\n    - id: magic\n      contents: 'GIF'\n    - id: version\n      type: str\n      size: 3\n      encoding: ASCII\n</code></pre> <p>The keyword <code>magic</code> is especially useful here as a safeguard, acting as a file signature when paired with the <code>contents</code> key. It checks that the first bytes match the contents, \"GIF\" in this case. The <code>magic</code> id is then followed by <code>version</code>, which grabs the next 3 bytes as denoted by <code>size</code> using the built-in <code>str</code> (string) type, and specifies that it is using <code>ASCII</code> encoding.</p> <p>This also highlights one of the bigger strengths of Kaitai: in general, it's pretty straightforward to read and understand. It is also for this reason that, if your project would benefit from having both a Kaitai and a Construct definition, it can be easier to first write your Kaitai description and base the Construct file off of that.</p> <p>This almost-plain-text description strength is also apparent in the next type, <code>logical_screen_descriptor_struct</code>:</p> <pre><code>logical_screen_descriptor_struct:\n  doc-ref: https://www.w3.org/Graphics/GIF/spec-gif89a.txt - section 18\n  seq:\n    - id: screen_width\n      type: u2\n    - id: screen_height\n      type: u2\n    - id: flags\n      type: u1\n    - id: bg_color_index\n      type: u1\n    - id: pixel_aspect_ratio\n      type: u1\n  instances:\n    has_color_table:\n      value: '(flags &amp; 0b10000000) != 0'\n    color_table_size:\n      value: '2 &lt;&lt; (flags &amp; 7)'\n</code></pre> <p>As you can see, it simply grabs the width and the height of the screen on which the GIF will be drawn as 2 unsigned bytes, followed by three unsigned bytes that describe the <code>flags</code>, <code>bg_color_index</code>, and <code>pixel_aspect_ratio</code>. </p> <p>Where it starts to get less straightforward to understand (at least in this example) is the <code>instances</code> section.</p>"},{"location":"04_kaitai_basics/#instances","title":"Instances","text":"<p>After the <code>id</code>s are set in the type <code>seq</code>, we then see the <code>instances</code> section. This section sets new variables by manipulating the previously found <code>flags</code> object using Kaitai's expression language.</p> <p>For example, <code>value: '(flags &amp; 0b10000000) != 0'</code> is doing something called \"bit masking\": taking the bits from the <code>flags</code> byte and showing only the first one. The beginning, <code>0b</code>, means to read the <code>flags</code> object as pure bytes, then the <code>1</code> means the first bit is allowed through while the rest are masked with <code>0</code>. The value is set as <code>True</code> or <code>False</code> depending on if the first bit is NOT (<code>!=</code>) equal to 0. This expression serves as a boolean operation. Either the GIF does or does not have a color table, and this status is encoded in the first bit of the <code>flags</code> byte.</p> <p>It's worth noting that <code>bytes</code> are not some fundamental unit of computation. The choice to have 8 bits in one byte was made by the International Organization for Standardization (ISO) and the International Electrotechnical Commission (IEC) in 1993, but 6- and 9-bit bytes were common through the 1960s. Bit masking allows you to use every individual bit or combination of bits in a selection to correspond to a different value, surpassing some of the artificially imposed limits on computation. This could come in especially useful if you are attempting to deal with archival data, or if your project would otherwise benefit from non-standard byte-sizing.</p> <p><code>color_table_size</code> is doing a similar operation but with different syntax. <code>7</code> in binary is <code>00000111</code>, so <code>(flags &amp; 7)</code> selects the final 3 bits. <code>2</code> in binary is <code>00000010</code> and <code>&lt;&lt;</code> is the command to \"shift\" bits to the left, so this command shifts \"2\" to the left by <code>(flags &amp; 7)</code> places. This is equivalent to raising 2 to the power of <code>1 + (flags mod 8)</code> and then assigning that new value to a character.</p> <p>In our case, <code>flags = 247</code> (<code>11110111</code> in binary), so <code>has_color_table = True</code>, and <code>1 + (flags mod 8) = 1 + (247 mod 8) = 1 + 7 = 8</code>. Then, \\(2^8 = 256\\), meaning that <code>color_table_size = 256</code>.</p> <p>All of this section has been to explain, in broad strokes, some of the types as shown in the GIF file type. If you're interested in reading more about Kaitai Struct Language, the full documentation can be found here.</p> <p>For now, let's continue this lesson and talk about how this same file type definition can be performed using the Construct library.</p> <p>Continue to Construct basics to learn how to describe file formats programmatically in Python.</p>"},{"location":"05_construct_basics/","title":"Defining the Structure in Construct","text":"<p>Construct is a Python library for declaratively describing and parsing binary data formats. Its functionality is similar to Kaitai Struct, but it was designed to be used with the Python expression language. In Construct, you define <code>Structs</code> (structures) that describe how to interpret sections of a binary file, which are like Kaitai's <code>types</code>. These <code>Structs</code> can be combined and nested to represent complex file formats, ultimately building up to a main <code>Struct</code> that captures the entire file's structure, similar to Kaitai's <code>seq</code>.</p>"},{"location":"05_construct_basics/#struct-basics","title":"Struct basics","text":"<p>A <code>Struct</code> in Construct is a collection of ordered fields, each with a name and a type. Fields are parsed or built in the order they are defined. When parsing, Construct returns a dictionary-like object with keys matching the field names. Unlike Kaitai, field names are optional in Construct, but naming fields makes the resulting data much easier to work with.</p> <p>Let's recreate the dimensions example from the Kaitai section. Here is how you would define an identical <code>width_and_height</code> <code>Struct</code> in Construct:</p> <pre><code>width_and_height = Struct(\n    \"width\" / Int16ul,\n    \"height\" / Int16ul\n)\n</code></pre> Quick aside: Style <p>    The indentation of this Struct isn't a requirement, but a stylistic choice to make it easier to read. Python would have no issues reading this instead as:    ```python   width_and_height = Struct(\"width\"/Int16ul, \"height\"/Int16ul)   ```   </p> <p>Here, <code>Int16ul</code> means an Integer of 16 unsigned bits in little-endian format. You can then reuse this <code>width_and_height</code> struct in other structures:</p> <pre><code>dimensions = Struct(\n    \"w_and_h\" / width_and_height\n)\n</code></pre> <p>This modular approach allows you to build up complex file formats from smaller, reusable pieces.</p>"},{"location":"05_construct_basics/#building-gifpy","title":"Building gif.py","text":"<p>Let's look at how Construct can be used to describe the GIF file format, using the gif.py example from Construct's GitHub repository.</p> <p>Unlike Kaitai, where types can be declared in any order, Python requires that each <code>Struct</code> be defined before it can be referenced. This means you typically define the smallest components first and then combine them into larger structures. When examining the structure of existing <code>Structs</code> then, it often makes sense to start from the final defined <code>Struct</code> and work backwards to see how everything is built to work together.</p> <p>Here is the top-level <code>gif_file</code> struct, which represents the entire GIF file:</p> <pre><code>gif_file = Struct(\n    \"signature\" / Const(b\"GIF\"),\n    \"version\" / Const(b\"89a\"),\n    \"logical_screen\" / gif_logical_screen,\n    \"data\" / GreedyRange(gif_data),\n    # \"trailer\" / Const(0x3B, Int8ul)  # Optional: GIF file terminator\n)\n</code></pre> <ul> <li><code>Const(b\"GIF\")</code> and <code>Const(b\"89a\")</code> ensure the file starts with the correct signature and version, similar to the <code>magic</code> keyword in Kaitai. However, this also means it will fail to parse if the version number is anything other than <code>89a</code>.</li> <li><code>logical_screen</code> and <code>data</code> are parsed using other structs defined above <code>gif_file</code>.</li> <li>The <code>GreedyRange()</code> command repeats the given <code>gif_data</code> struct until the end of the file.</li> </ul> <p>Now, let's look at the <code>gif_logical_screen</code> struct:</p> <pre><code>gif_logical_screen = Struct(\n    \"width\" / Int16ul,\n    \"height\" / Int16ul,\n    \"flags\" / BitStruct(\n        \"global_color_table\" / Bit,\n        \"color_resolution\" / BitsInteger(3),\n        \"sort_flag\" / Bit,\n        \"global_color_table_bpp\" / BitsInteger(3),\n    ),\n    \"bgcolor_index\" / Int8ul,\n    \"pixel_aspect_ratio\" / Int8ul,\n    \"palette\" / If(this.flags.global_color_table,\n        Array(lambda this: 2**(this.flags.global_color_table_bpp + 1),\n            Struct(\n                \"R\" / Int8ul,\n                \"G\" / Int8ul,\n                \"B\" / Int8ul,\n            )\n        )\n    ),\n)\n</code></pre> <ul> <li><code>BitStruct</code> allows you to parse individual bits within a byte, which is useful for fields like <code>flags</code> that pack multiple values into a single byte.</li> <li>The <code>palette</code> field is only present if <code>global_color_table</code> is <code>True</code>. Its length is determined by the value of <code>global_color_table_bpp</code>.</li> </ul> <p>The <code>data</code> section of the GIF file is parsed using a combination of <code>Struct</code>, <code>Switch</code>, and <code>GreedyRange</code>:</p> <pre><code>gif_data = Struct(\n    \"introducer\" / Int8ul,\n    \"data\" / Switch(this.introducer, {\n        0x21: extension,\n        0x2C: image_descriptor,\n    })\n)\n</code></pre> <ul> <li>The <code>introducer</code> byte determines whether the next section is an extension or an image descriptor.</li> <li><code>Switch</code> selects the appropriate struct based on the value of <code>introducer</code>.</li> <li>Each of these sub-structs (<code>extension</code>, <code>image_descriptor</code>) is defined elsewhere in the file.</li> </ul> <p>As mentioned earlier, having <code>GreedyRange(gif_data)</code> in the top-level struct repeats this process for each data block in the file, allowing Construct to parse the entire sequence of GIF blocks.</p> <p>This modular, programmatic approach makes Construct powerful for describing binary formats in Python. While Kaitai uses a declarative YAML-based syntax, Construct leverages Python's syntax and logic, which can be more flexible for complex parsing tasks.</p> <p>Now that you have seen how to describe file formats in both Kaitai and Construct, the next step is to create your own custom data format and try parsing it using these tools. Continue to the next section to learn how to generate and work with example data.</p> <p>Continue to Creating Example Data to generate and save your own binary data.</p>"},{"location":"06_creating_example_data/","title":"Creating Example Data","text":"<p>Now that you understand the basics of file formats and parsing tools, let's put everything together by generating some example data, saving it in a binary file, and preparing to describe its structure with Kaitai and Construct. This hands-on section will help you see how real binary data is created and organized.</p> <p>Suppose we want to simulate a waveform and store it in a binary file. For demonstration, imagine we're measuring vibrations or current intensity. Since we're fabricating data, the context is flexible.</p> <p>We'll use Python for this example, as it's required for Construct. If you haven't set up your Python environment yet, return to the setup section for instructions.</p>"},{"location":"06_creating_example_data/#designing-the-data-structure","title":"Designing the Data Structure","text":"<p>Let's divide our data into three sections based on intensity: - Full data: The entire waveform. - Mid-range data: Only points where the signal is moderate. - Peak data: Only the most intense points.</p> <p>This could represent three sensors with different sensitivities.</p>"},{"location":"06_creating_example_data/#preparing-your-environment","title":"Preparing Your Environment","text":"<p>You'll need the following Python libraries: - <code>numpy</code> (for numerical arrays) - <code>struct</code> (for binary packing; different from Construct) - <code>matplotlib</code> (optional, for plotting)</p> <p>To check if these are installed, run:</p> <pre><code>pip list\n</code></pre> <p>If you don't see <code>numpy</code> or <code>matplotlib</code>, install them with:</p> <pre><code>pip install numpy\npip install matplotlib\n</code></pre> <p>Note: <code>struct</code> is part of the Python standard library and doesn't require installation.</p>"},{"location":"06_creating_example_data/#creating-and-visualizing-the-data","title":"Creating and Visualizing the Data","text":"<p>Create a new <code>.py</code> or <code>.ipynb</code> file (e.g., <code>example_data.py</code>). You can also reference the example notebook.</p> <p>Import the necessary modules:</p> <pre><code>import numpy as np\nimport struct\nimport matplotlib.pyplot as plt\n</code></pre> <p>Now, initialize arrays for each section:</p> <pre><code>full_x, full_y = [], []\nmid_x, mid_y = [], []\npeak_x, peak_y = [], []\n</code></pre> <p>Populate these arrays with simulated data. For this example, we'll generate 100,000 points from <code>x = -5</code> to <code>x = 5</code> using the (totally arbitrary) equation \\(y=cos(\\frac{2 \\pi x^2}{x^2 +x})sin(x)\\):</p> <pre><code>for x in np.arange(-5, 5, 0.0001):\n    y = (np.cos((2 * np.pi * x**2)/(x**2 + x))) * np.sin(x)\n    full_x.append(x)\n    full_y.append(y)\n    if y**2 &lt; 0.3:\n        mid_x.append(x)\n        mid_y.append(y)\n    if y**2 &gt; 0.65:\n        peak_x.append(x)\n        peak_y.append(y)\n</code></pre> <p>You can then visualize the data:</p> <pre><code>plt.plot(full_x, full_y)\nplt.title(\"Full Data\")\nplt.show()\n\nplt.plot(mid_x, mid_y)\nplt.title(\"Mid-range Data\")\nplt.show()\n\nplt.scatter(peak_x, peak_y, s=1)\nplt.title(\"Peak Data\")\nplt.show()\n</code></pre> <p>The resulting graphs should look like:</p> <p> </p>"},{"location":"06_creating_example_data/#saving-data-as-binary","title":"Saving Data as Binary","text":"<p>Convert your lists to numpy arrays with a specific data type (e.g., <code>float32</code> for 4 bytes per value):</p> <pre><code>full_x_data = np.array(full_x, dtype=np.float32)\nfull_y_data = np.array(full_y, dtype=np.float32)\nmid_x_data = np.array(mid_x, dtype=np.float32)\nmid_y_data = np.array(mid_y, dtype=np.float32)\npeak_x_data = np.array(peak_x, dtype=np.float32)\npeak_y_data = np.array(peak_y, dtype=np.float32)\n</code></pre> <p>By default, the binary data is written using your operating system's native endianness. If you want to ensure consistency, you can explicitly set the endianness here:</p> <pre><code># For little-endian\nfull_x_data = np.array(full_x, dtype='&lt;float32')  # or '&lt;f4'\n\n# For big-endian\nfull_x_data = np.array(full_x, dtype='&gt;float32')  # or '&gt;f4'\n</code></pre> <p>When saving binary data, it's helpful to include the length of each section at the start of the file or near the front of its respective section. This makes parsing easier later. </p> <pre><code>with open('wave_data.test', 'wb') as f:\n    # Write single array lengths as unsigned 4-byte integers\n    f.write(struct.pack('I', len(full_y_data)))\n    f.write(struct.pack('I', len(mid_y_data)))\n    f.write(struct.pack('I', len(peak_y_data)))\n    # Write all arrays in order\n    full_x_data.tofile(f)\n    full_y_data.tofile(f)\n\n    mid_x_data.tofile(f)\n    mid_y_data.tofile(f)\n\n    peak_x_data.tofile(f)\n    peak_y_data.tofile(f)\n</code></pre> <p>You now have a binary file called <code>wave_data.test</code> in your working directory. The file extension is arbitrary; modern systems do not require three-letter extensions.</p> <p>Continue to Kaitai Next Steps to describe and parse your custom data with Kaitai Struct.</p>"},{"location":"07_kaitai_next_steps/","title":"Describing the Data in Kaitai","text":"<p>Now that you have created a custom binary file, let's describe its structure using Kaitai Struct. This will allow you to parse and analyze your data with generated code.</p> <p>If you don't have the Kaitai Web IDE open, navigate there and create a new <code>.ksy</code> file (e.g., <code>wave_parser.ksy</code>). You can also reference the example file.</p>"},{"location":"07_kaitai_next_steps/#writing-the-kaitai-description","title":"Writing the Kaitai Description","text":"<p>We're about to create the <code>.ksy</code> files used to parse our example format, you are encouraged to try and create the file using what you've learned so far, but solutions will be provided for each section as well.</p> You can also download the example ksy file to compare your work to by clicking here. <p>Download wave_parser.ksy</p>"},{"location":"07_kaitai_next_steps/#meta-section","title":"Meta Section","text":"<p>The first step for creating our <code>.ksy</code> file will be to fill out the <code>meta</code> section. The <code>id</code> and file extension are often identical, and should be the same as what you entered as the file extension when writing the file. Then you will assert if the file is either in little-endian, <code>le</code>, or big-endian, <code>be</code>.</p> Show solution <p> <pre><code>meta:\n  id: test\n  file-extension: test\n  endian: le\n</code></pre> </p>"},{"location":"07_kaitai_next_steps/#describing-the-file-structure","title":"Describing the File Structure","text":"<p>Recall that when saving your binary file, we wrote three unsigned 4-byte integers at the start, representing the lengths of each data section. We can start off by describing these numbers in a <code>type</code> before using that <code>type</code> definition in <code>seq</code>. While it may feel unnatural to write non-linearly, it is very common for working with Kaitai.</p> Show solution <p> <pre><code>seq:\n  - id: lengths\n    type: full_mid_peak_lens\n\ntypes:\n  full_mid_peak_lens:\n    seq:\n      - id: full_len\n        type: u4\n      - id: mid_len\n        type: u4\n      - id: peak_len\n        type: u4\n</code></pre> </p> <p>Next, define the structure for each section of the data (full/mid/peak). Recall that when writing the data, we only used the length of one axis, but we need to capture both the x- and y-data. This capture will require us to use a <code>repeat-expr</code> which repeats the <code>f4</code> type as many times as the length of the axis. As an example, the syntax for a <code>repeat-expr</code> for <code>full_data</code> could be written as:</p> <pre><code>repeat: expr\nrepeat-expr: _root.length.full_len\n</code></pre> Show solution <p> <pre><code>  full_data:\n    seq:\n      - id: x_data\n        type: f4\n        repeat: expr\n        repeat-expr: _root.lengths.full_len\n      - id: y_data\n        type: f4\n        repeat: expr\n        repeat-expr: _root.lengths.full_len\n\n  mid_data:\n    seq:\n      - id: x_data\n        type: f4\n        repeat: expr\n        repeat-expr: _root.lengths.mid_len\n      - id: y_data\n        type: f4\n        repeat: expr\n        repeat-expr: _root.lengths.mid_len\n\n  peak_data:\n    seq:\n      - id: x_data\n        type: f4\n        repeat: expr\n        repeat-expr: _root.lengths.peak_len\n      - id: y_data\n        type: f4\n        repeat: expr\n        repeat-expr: _root.lengths.peak_len\n</code></pre> </p> <p>Finally, add all of these sections to the main <code>seq</code>.</p> Show solution <p> <pre><code>  - id: f_data\n    type: full_data\n  - id: m_data\n    type: mid_data\n  - id: p_data\n    type: peak_data\n</code></pre> </p> <p>Your <code>.ksy</code> file should now fully describe the structure of your binary file.</p>"},{"location":"07_kaitai_next_steps/#parsing-raw-data-with-a-ksy-file","title":"Parsing Raw Data with a .ksy File","text":"<p>From your terminal, generate the parser (for Python):</p> <pre><code>ksc -t &lt;language&gt; --outdir &lt;new_foldername&gt; &lt;path/to/your/file.ksy&gt;\n</code></pre> <p>Replacing the parts in the brackets accordingly. For language, the options are: <code>cpp_stl</code>, <code>csharp</code>, <code>java</code>, <code>javascript</code>, <code>perl</code>, <code>php</code>, <code>python</code>, <code>ruby</code>, or <code>all</code>. For this example, we'll be running:</p> <pre><code>ksc -t python --outdir wave_test wave_parser.ksy\n</code></pre> <p>This will create a folder (<code>wave_test</code>) containing a Python file (<code>test.py</code>).</p>"},{"location":"07_kaitai_next_steps/#loading-and-using-the-parser-in-python","title":"Loading and Using the Parser in Python","text":"<p>Make sure your generated parser and your binary data file are in the same directory or update your import paths accordingly.</p> <p>Example usage in Python:</p> <pre><code>from pathlib import Path\nfrom wave_test.test import *  # Replace with the actual class name from your .ksy meta:id\nimport matplotlib.pyplot as plt\n\nraw_data = Path('wave_data.test')\nwave_data = Test.from_file(raw_data)\n\n# Access lengths\nf_length = wave_data.lengths.full_len\nm_length = wave_data.lengths.mid_len\np_length = wave_data.lengths.peak_len\nprint(f_length, m_length, p_length)\n\n# Access and plot full data\nfull_x = wave_data.f_data.x_data\nfull_y = wave_data.f_data.y_data\nplt.plot(full_x, full_y)\nplt.title(\"Full Data\")\nplt.show()\n</code></pre> <p>Repeat for <code>m_data</code> and <code>p_data</code> as needed.</p> <p>You have now described and parsed your custom binary file using Kaitai Struct!  Continue to Construct Next Steps to parse your custom data with the Construct library.</p>"},{"location":"08_construct_next_steps/","title":"Describing the Data in Construct","text":"<p>Now that you've described your custom binary file in Kaitai, let's do the same using the Construct library in Python. This section will guide you through building Structs to match your file layout, parsing the data, and visualizing the results.</p> <p>We're about to create the <code>.ipynb</code> file used to parse our example format, you are encouraged to follow along and try to create the file yourself. </p> You can download the example file to compare your work to by clicking here <p>Download example_struct.ipynb</p>"},{"location":"08_construct_next_steps/#setting-up-and-defining-structs","title":"Setting Up and Defining Structs","text":"<p>Start by importing the required libraries:</p> <pre><code>from construct import *\nimport matplotlib.pyplot as plt\nimport numpy as np\n</code></pre> <p>Recall that your binary file starts with three 4-byte unsigned integers, giving the lengths of one axis for each of the full, mid, and peak data arrays. Try creating the first Struct to capture axis lengths for full, mid, and peak data.</p> Show solution <p> <pre><code>lengths_struct = Struct(\n    \"full_data_len\" / Int32ul,\n    \"mid_data_len\" / Int32ul,\n    \"peak_data_len\" / Int32ul\n)\n</code></pre> </p> <p>Next, define a Struct for the data arrays. Construct is able to capture them directly as arrays using <code>Array(count, subcon)</code> syntax, where <code>count</code> is the number of elements and <code>subcon</code> defines the format of each element. <code>count</code> can be described similar to the <code>repeat-expr</code> in Kaitai, although proceeded by <code>this</code>, so it should look like <code>this._root.lengths.full_data_len</code>.</p> Show solution <p> <pre><code>data_sections = Struct(\n    \"full_x_data\" / Array(this._root.lengths.full_data_len, Float32l),\n    \"full_y_data\" / Array(this._root.lengths.full_data_len, Float32l),\n\n    \"mid_x_data\" / Array(this._root.lengths.mid_data_len, Float32l),\n    \"mid_y_data\" / Array(this._root.lengths.mid_data_len, Float32l),\n\n    \"peak_x_data\" / Array(this._root.lengths.peak_data_len, Float32l),\n    \"peak_y_data\" / Array(this._root.lengths.peak_data_len, Float32l),\n)\n</code></pre> </p> <p>Finally, you can combine these into the top-level Struct.</p> Show solution <pre><code>test_struct = Struct(\n    \"lengths\" / lengths_struct,\n    \"data_sects\" / data_sections\n)\n</code></pre> <p>Tip: You can name your sub-Structs however you like, but be consistent. The quoted names (e.g., <code>\"data_sects\"</code>) are the keys you'll use to access the parsed data.</p>"},{"location":"08_construct_next_steps/#parsing-and-visualizing-the-data","title":"Parsing and Visualizing the Data","text":"<p>Parsing with Construct is straightforward. You can do everything in the same script or notebook. The following function opens the binary file, parses it using your defined Struct, extracts the x and y arrays for each data range, and then plots them using Matplotlib:</p> <pre><code>def parse_file(input_path):\n    with open(input_path, 'rb') as input_f:\n        raw_data = input_f.read()\n        parsed_data = test_struct.parse(raw_data)\n\n    # Extract arrays\n    full_x = parsed_data.data_sects.full_x_data\n    full_y = parsed_data.data_sects.full_y_data\n    mid_x = parsed_data.data_sects.mid_x_data\n    mid_y = parsed_data.data_sects.mid_y_data\n    peak_x = parsed_data.data_sects.peak_x_data\n    peak_y = parsed_data.data_sects.peak_y_data\n\n    # Plot full data\n    plt.plot(full_x, full_y)\n    plt.title(\"Full Data\")\n    plt.show()\n\n    # Plot mid-range data\n    plt.plot(mid_x, mid_y)\n    plt.title(\"Mid-range Data\")\n    plt.show()\n\n    # Plot peak data\n    plt.scatter(peak_x, peak_y, s=1)\n    plt.title(\"Peak Data\")\n    plt.show()\n</code></pre> <p>Call your function with the path to your binary file:</p> <pre><code>parse_file(\"wave_data.test\")\n</code></pre> <p>You should see the same plots as when you generated the data, confirming that your Structs correctly describe the file format.</p> <p>You have now parsed your custom binary file using Construct! This approach mirrors the Kaitai description from the previous section, and you can adapt it for more complex formats as needed.</p> <p>Continue to the conclusion for final thoughts and resources.</p>"},{"location":"09_conclusion/","title":"Conclusion","text":"<p>Congratulations on completing this lesson on custom binary data formats! If you've followed along careful, you should have learned:</p> <ul> <li>That files have defined formats, and that software is designed to be able read their data.</li> <li>How to examine raw binary data in Kaitai using the Kaitai web IDE.</li> <li>How to use Kaitai Struct to describe and parse binary file formats in a declarative way.</li> <li>How to use the Construct library in Python to programmatically parse and build binary data.</li> <li>How to create, save, and visualize your own example binary data.</li> </ul> <p>These skills are foundational for working with scientific, engineering, or custom data formats that are not supported by standard software. Kaitai and Construct are both powerful and flexible, and can be applied to a wide range of real-world binary data.</p> <p>Remember, this lesson only scratches the surface of what you can do with these tools. Both Kaitai and Construct have extensive documentation and active communities:</p> <ul> <li>Kaitai Struct: </li> <li>Official documentation</li> <li>Gitter community chat</li> <li>Construct: </li> <li>Official documentation</li> <li>GitHub repository</li> </ul> <p>If you are working with volumetric or astronomical data, consider joining the yt project's mailing lists for users or developers of the yt Python package: - yt-dev mailing list - yt-users mailing list</p> <p>For further assistance, you can also contact Professor Amy Roberts at the University of Colorado Denver for software and analysis help: amy.roberts@ucdenver.edu</p> <p>For installation help and advanced options, see the Appendix.</p> <p>If you get stuck, remember to consult the official documentation and reach out to the community. Good luck, and happy coding!</p>"},{"location":"10_appendix/","title":"Appendix","text":""},{"location":"10_appendix/#kaitai-installation","title":"Kaitai Installation","text":"<p>While the Kaitai Web IDE is sufficient for most users, you may want to install the Kaitai Struct Compiler (<code>ksc</code>) locally if you need to:</p> <ul> <li>Generate parser code for use in your own projects (Python, Java, C#, etc.)</li> <li>Work offline or automate parser generation</li> <li>Use the Kaitai Struct Visualizer (<code>ksv</code>) for console-based visualization</li> </ul> <p>You can download installers for your operating system from the Kaitai Struct download page.</p> <p>After installation, you should have access to:</p> <ul> <li><code>ksc</code> (<code>kaitai-struct-compiler</code>): Command-line tool to compile <code>.ksy</code> files into parsing libraries for your chosen language.</li> <li><code>ksv</code> (<code>kaitai-struct-visualizer</code>, optional): Console-based visualizer for Kaitai Struct files.</li> </ul> <p>For usage instructions, see the official Kaitai documentation.</p>"},{"location":"10_appendix/#additional-construct-installation","title":"Additional Construct Installation","text":"<p>The main Construct library is sufficient for this lesson. However, if you want to install all optional modules (for advanced features or additional protocol support), use:</p> <pre><code>pip install construct[extras]\n</code></pre> <p>For more details, refer to the Construct documentation.</p> <p>If you encounter installation issues, check the official documentation or community forums linked in the conclusion.</p>"}]}