{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#project-layout","title":"Project layout","text":"<p>Created by Adrian Fisher</p> <pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md                    # The documentation homepage.\n    01_introduction.md          # Explaining the purpose of the lesson\n    02_setup.md                 # How to install and use Kaitai and Construct\n    03_filetype.md              # Describing file formats, types, and the basics of computer language\n    04_kaitai_basics.md         # Describing the basics of using Kaitai\n    05_construct_basics.md      # Describing the basics of using Construct\n    06_creating_example_data.md # Creating an example raw data file\n    07_kaitai_next_steps.md     # Parsing the example data file with Kaitai\n    08_construct_next_steps.md  # Parsing the example data file with Construct\n    09_conclusion.md            # Final thoughts and resources\n    10_appendix.md              # Installation resources and advanced options\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"01_introduction/","title":"1: Introduction","text":"<p>In scientific computing, data is often stored in custom binary formats. These formats might be tailored for specific instruments, simulations, or to optimize for storage space or read/write speed. However, a major drawback is that standard analysis software and programming language libraries usually cannot interpret these specialized binary structures directly.</p> <p>This lack of interoperability creates a hurdle: before the data can be analyzed or shared effectively, its binary layout must be explicitly defined and parsed. This lesson addresses this common challenge. We will explore how to set up and use two powerful tools:</p> <ol> <li>Kaitai Struct: A YAML based declarative language for describing binary data structures, which can generate parser code in various languages (Python, C#, Java, JavaScript, Perl, PHP, Ruby).</li> <li>Construct: A Python library for parsing and building binary data structures.</li> </ol> <p>We will guide you through installing these tools and then demonstrate how they enable you to translate custom binary data into readily usable formats for your analysis workflows.</p> <p>Continue to Setup to get your environment ready.</p>"},{"location":"02_setup/","title":"2. Setup","text":""},{"location":"02_setup/#objectives","title":"Objectives:","text":"<ul> <li>Learn how to setup and work with the Kaitai IDE and the Construct Python library.</li> </ul>"},{"location":"02_setup/#2-setup","title":"2: Setup","text":"<p>This section will guide you through setting up the tools needed for this lesson: the Kaitai Web IDE (for describing binary formats) and the Construct Python library (for parsing them in Python). By the end, you'll be ready to follow along with all code examples.</p>"},{"location":"02_setup/#21-kaitai-ide","title":"2.1 Kaitai IDE","text":"<p>No installation is required for most users. Simply open the Kaitai Web IDE in your browser. - To get started:   1. Go to https://ide.kaitai.io/   2. Click \"New\" to create a new .ksy file   3. Follow the instructions in Section 4: Defining the Structure in Kaitai</p> <p>Advanced users: If you want to use Kaitai offline or generate parsers locally, see the appendix for installing <code>ksc</code> and <code>ksv</code>.</p>"},{"location":"02_setup/#22-python-and-ide-setup","title":"2.2 Python and IDE Setup","text":"<p>To use Construct, you need Python 3.6 or newer. - Download Python from python.org if you don't have it. - Check your Python version:     <code>bash     python --version</code></p> <p>We recommend using a Python virtual environment to keep your dependencies isolated. To set up a virtual environment using <code>virtualenv</code>:</p> <ol> <li>Install <code>virtualenv</code> if you don't have it:     <code>bash     pip install --user virtualenv</code></li> <li>Create a new environment (replace <code>env</code> with your preferred name):     <code>bash     python -m virtualenv env</code></li> <li>Activate the environment:<ul> <li>On Linux/macOS:     <code>bash     source env/bin/activate</code></li> <li>On Windows:     <code>bash     .\\env\\Scripts\\activate</code></li> </ul> </li> </ol> <p>You can use any IDE (e.g., VS Code, PyCharm, Anaconda), but we recommend Spyder for beginners.</p>"},{"location":"02_setup/#23-construct-setup","title":"2.3 Construct Setup","text":"<p>With your virtual environment activated, install Construct:</p> <pre><code>pip install construct\n</code></pre> <p>If you encounter installation issues, refer to the Appendix or consult the official documentation for Kaitai and Construct.</p> <p>Continue to File types and formats to learn how computers interpret and store different file types.</p>"},{"location":"03_filetype/","title":"3. File types","text":""},{"location":"03_filetype/#objectives","title":"Objectives:","text":"<ul> <li>Understand what a file type is and what a file format is.</li> <li>Understand why computers use binary, how to represent binary with hexadecimals, and why it makes sense to do so.</li> <li>Take a look at a file's raw data to explain how computers open files.</li> </ul>"},{"location":"03_filetype/#3-what-is-a-file-type","title":"3: What is a file type?","text":"<p>As we're about to begin exploring the mechanics of computers and programs on a more fundamental level than the average consumer might be used to, it's important to remember that we are navigating culturally specific conventions and abstractions that have been built up over several decades. During this time, humanity has been working on simplifying and making accessible some incredibly complex physics engines which have given us the ability to relate the laws of electromagnetism into our world of signs and symbols. After nearly a century of refining our processes and methods, we now have access to almost unthinkably complex devices which we call things like \"graphics processing units\", or \"Random Access Memory cards\", which can fit into your pocket and deliver you pictures of cats from around the world. </p> <p>So, when we say a <code>.jpg</code> file \"is a picture\", a <code>.gif</code> file \"is an animation\", or a <code>.txt</code> file \"is a text document\", we're relying on conventions that help computers and humans organize and interpret data. But how does a computer actually know what to do with a file? Let's step back and explore how data is stored, and how we've managed to trick silicon and copper into turning electrons into something humans can understand and interact with.</p> <p>A file type is usually indicated by the extension at the end of a file's name, such as <code>.jpg</code>, <code>.gif</code>, or <code>.txt</code>. This extension suggests to programs which format\u2014the actual structure and encoding of the data\u2014to use when reading the file. However, the extension is only a hint; the true format is defined by how the data is organized inside the file.</p> <p>Sometimes, different file types share the same format (e.g., <code>.jpg</code> and <code>.jpeg</code>), and sometimes a single file type can refer to many different formats (e.g., <code>.bin</code> for binary data). These conventions are not strict rules. If you try to open a file with the wrong program, the data may be misinterpreted or unreadable.</p> <p>As new needs arise, developers define new file formats and create the software needed to interpret the raw binary data and present it in a way humans can understand.</p>"},{"location":"03_filetype/#31-computer-language-and-number-systems","title":"3.1: Computer language and number systems","text":"<p>A file format is a set of instructions that a program uses to open, edit, and/or save a file. At the lowest level, all data on a computer is stored as a sequence of <code>1</code>s and <code>0</code>s\u2014binary digits, or bits. But how are these bits generated and used?</p> <p>When you type a character in a <code>.txt</code> document, your keyboard completes a circuit, sending a signal to its microcontroller. This signal is converted into a binary representation\u2014a sequence of <code>1</code>s and <code>0</code>s. This description is an abstraction for the physical state of transistors and capacitors in memory cells: a charged capacitor represents a <code>1</code>, and a discharged one a <code>0</code>. This is true even for files saved \"in the cloud\"\u2014somewhere, physical hardware is storing those bits.</p> <p> Woodford, Chris, (2022). Computer Keyboards, source</p> <p>For example, the character <code>a</code> becomes the binary <code>01100001</code>. Each character is represented by a byte (8 bits). Since binary is a base two system, one byte can represent any value from <code>00000000</code> to <code>11111111</code> (0 to 255 in decimal).</p>"},{"location":"03_filetype/#311-counting-in-binary-and-hexadecimals","title":"3.1.1: Counting in binary and hexadecimals","text":"<p>As a side effect of finding ourselves with 10 fingers (usually), humans have developed a base 10 (decimal) numerical system. In base 10, the number \"3125\" can be thought of as:</p> \\[ 3125 = (3 \\cdot 10^3) + (1 \\cdot 10^2) + (2 \\cdot 10^1) + (5 \\cdot 10^0) \\] <p>Each new digit to the left of the implied decimal point represents an additional \\(10^n\\), where \\(n\\) is the digit's index, starting from 0. So 3125 has a 3 in the \"thousand\" or \\(10^3\\) place, a 1 in the \"hundred\" or \\(10^2\\) place, a 2 in the \"ten\" or \\(10^1\\) place, and a 5 in the \"one\" or \\(10^0\\) place. This can be continued for digits smaller than 1 as well\u2014on the other side of the decimal point. In this case, \\(n \\lt 0\\), so 0.1 can be similarly represented as (\\(1 \\cdot 10^{-1}\\)), 0.01 as (\\(1 \\cdot 10^{-2}\\)) and so on.</p> <p>Binary works the same way, but with powers of 2. For example, <code>01100001</code> in binary is:</p> \\[ (0 \\cdot 2^7) + (1 \\cdot 2^6) + (1 \\cdot 2^5) + (0 \\cdot 2^4) + (0 \\cdot 2^3) + (0 \\cdot 2^2) + (0 \\cdot 2^1) + (1 \\cdot 2^0) = 97 \\] <p>Hexadecimal is base 16, using symbols 0-9 and A-F (A=10, ..., F=15). Each hexadecimal digit represents four bits (a \"nibble\"), so one byte can be expressed using only two hexadecimal characters. This makes the hexadecimal counting system much more compact in its ability to represent binary data. For example, <code>a</code> can be represented as:</p> <ul> <li>Binary: <code>01100001</code></li> <li>Decimal: <code>97</code></li> <li>Hexadecimal: <code>61</code></li> </ul> \\[ (6 \\cdot 16^1) + (1 \\cdot 16^0) = 97 \\] <p>To summarize: when you type a character, a number between 0 and 255 is stored in your document. Programs use instructions (file formats) to translate these values into something meaningful.</p> <p>So, how does your computer take a large number saved in memory and turn it into a document you can understand? How do text editors know to open a <code>.txt</code> file and represent <code>01100001</code> as the letter <code>a</code>?</p>"},{"location":"03_filetype/#312-endianness","title":"3.1.2: Endianness","text":"<p>One of the first steps a computer follows when opening a file relates to endianness, or the order in which bytes of a given \"word\" (a fixed number of bytes set by the computer's processor) are to be read. There are two types:</p> <ul> <li>Big-endian (BE): The most significant byte comes first (at the lowest memory address).</li> <li>Little-endian (LE): The least significant byte comes first (at the lowest memory address).</li> </ul> <p>Suppose a word is four bytes, and you want to write the number <code>2024</code>:</p> Endianness Byte Order (hex) Big-endian 00 00 07 E8 Little-endian E8 07 00 00 <p>If a file is saved using one endianness but opened using another, the bytes will be misinterpreted. Think of it as similar to trying to read a manga from left to right, or a novel starting from the last word on the last page. Many file formats include a byte order mark (BOM) to indicate which endianness to use.</p>"},{"location":"03_filetype/#32-opening-a-file-with-a-text-editor","title":"3.2: Opening a file with a text editor","text":"<p>Plain text editors convert binary data into legible characters using encodings such as UTF-8 or ASCII. UTF-8 is the most widely used encoding and is backwards compatible with ASCII for the first 128 characters.</p> <p>The following table shows how each byte value maps to a character in UTF-8:</p> <p> UTF-8 Byte Map, from Wikipedia</p> <p>In this table, the row selects the first hex character of a byte and the column selects the second. For example, the letter <code>a</code> (hex <code>61</code>) is found at row 6, column 1.</p> <p>This table helps explain why some bytes in a binary file appear as readable characters when opened in a text editor.</p> <p>Text editors work well for text files, but what happens if you open file that a text editor wasn't designed for, like a GIF? Let's test it out by using this GIF file from Wikipedia:</p> <p> Rotating_earth_(large).gif, from Wikipedia</p>"},{"location":"03_filetype/#321-text-editor-setup","title":"3.2.1: Text editor setup","text":"<p>Which text editor to use depends on your operating system:</p> <ul> <li>Windows: Notepad</li> <li>macOS: TextEdit</li> <li>Ubuntu/Linux: Gedit (others: Kate, Kwrite, Geany, etc.)</li> </ul> <p>You can usually right-click (or command-click on macOS) a file and select \"Open With\" to choose your text editor. If you need to use the terminal, search for instructions specific to your OS and editor (e.g., \"How to open a file in Notepad using Command Prompt\").</p> <p>Now, open the GIF file in your text editor. The result should appear as a jumble of seemingly nonsensical characters, such as:</p> <p></p> <p>Notice that among the symbols, some readable text appears\u2014such as \"GIF\" at the start (the file signature) and \"NETSCAPE2.0\" further down. These are parts of the file format specification that are stored as plain ASCII within the binary data.</p> <p>A program designed to open a GIF file uses all of these bytes\u2014both readable and unreadable\u2014to determine properties like image width, height, frame count, and pixel colors.</p> <p>While tools like Kaitai and Construct (covered in later sections) don't display the animation directly, they allow you to parse and interpret the raw data, making it possible to extract and use this information in your own programs.</p> <p>Continue to Kaitai basics to start describing file formats declaratively.</p>"},{"location":"04_kaitai_basics/","title":"4. Kaitai basics","text":""},{"location":"04_kaitai_basics/#objectives","title":"Objectives:","text":"<ul> <li>Understand how to begin working with Kaitai and the basics of its syntax.</li> <li>Explore the Kaitai description for the GIF filetype to see it in action.</li> </ul>"},{"location":"04_kaitai_basics/#4-defining-the-structure-in-kaitai","title":"4: Defining the Structure in Kaitai","text":"<p>Let's try loading the GIF file in the Kaitai Web IDE to understand this better. Start by navigating to the Kaitai Web IDE if you don't already have it open.</p>"},{"location":"04_kaitai_basics/#41-anatomy-of-the-web-ide","title":"4.1: Anatomy of the Web IDE","text":"<p>On the left side of the webpage, you'll see a list of folders, each containing pre-built <code>.ksy</code> files you can use to test functionality. For this example, navigate to <code>formats/image/gif.ksy</code> and double-click <code>gif.ksy</code> to load it into the IDE. The buttons on the bottom left of the webpage are for creating new <code>.ksy</code> files, uploading <code>.ksy</code> or data files, and saving <code>.ksy</code> files:</p> <p></p> <pre><code>New, Upload, Save\n</code></pre> <p>Click the upload button to select a <code>.gif</code> file from your computer and load it here. You should now see a webpage that looks like:</p> <p></p> <p>The viewer on the far right side should look somewhat familiar: it's the same data as when the file was opened in Notepad, but with unreadable symbols replaced by <code>.</code>s, showing the typeable characters alongside their hexadecimal representations.</p> <p>If you highlight specific characters or sets of characters on either side of the <code>hex viewer</code>, the corresponding characters will be highlighted on the other side as well, allowing you to see both the hex code and UTF-8/ASCII representations for any selection. This is also true for the <code>object tree</code> section. By clicking on an item in the <code>object tree</code> (such as the <code>hdr</code> section), the bytes described by the section are automatically selected in the <code>hex viewer</code>.</p> <p>In the same window as the <code>hex viewer</code> are the <code>JS Code</code> and <code>JS Code (debug)</code> sections. These show how the <code>.ksy</code> file is being translated into JavaScript, alongside a debugger.</p> <p>The <code>converter</code> section on the bottom right provides multiple ways to convert selected characters, showing different methods of translating a hex code as an integer (e.g., <code>i8</code> for an 8-bit integer, <code>i16le</code> for a 16-bit integer in little-endian format, etc.).</p> <p>Finally, there is the <code>info panel</code>, which provides information about a selection of bytes, such as the length of the selection and where in the data stream the selection is.</p> <p>If you are interested in following along more precisely with the <code>gif.ksy</code> file, there is also extensive documentation provided to describe the file format. Having documentation about the file format is crucial for describing your file type. Without documentation to follow, this process looks less like declarative programming and more like cryptography, as you would have to decipher and assume/assert the purposes of much of the data unless it happens to be written in plain text already.</p> <p>We won't fully describe everything being done in the example <code>.ksy</code> file here. Instead, we'll look at a broad overview to give an idea of Kaitai's functionality. Now that we know what we're looking at in the IDE, we can take a look at how the file type is being described.</p>"},{"location":"04_kaitai_basics/#42-meta-and-seq","title":"4.2: meta and seq","text":"<p>Your <code>.ksy</code> files should always start with a <code>meta</code> section, defining meta-information about your file type such as the file extension (like <code>.gif</code> or <code>.tiff</code>), title, license, endianness, cross-references, documentation, version, types, encodings, etc.</p> <p>The <code>seq</code> section is where the declarative work really starts. In <code>seq</code>, you describe how to handle the raw data. Each entry in <code>seq</code> must declare an <code>id</code> (the name shown in the object tree for that attribute). You can also specify a <code>type</code> (how to interpret the data), a <code>size</code> (number of bytes to capture), <code>contents</code> (for magic signatures), <code>encoding</code>, and more.</p> <p>When reading the raw data of our GIF, Kaitai will apply the <code>header</code> type until its conditions are fulfilled, then the <code>logical_screen_descriptor_struct</code> type, then <code>color_table</code> type, and finally the <code>blocks</code> type. If any type conditions are not fulfilled, the IDE will interrupt parsing and display an error message underneath the object tree.</p> <p>Instead of investigating all four different <code>types</code> in the file's <code>seq</code>, let's look only at the first two: <code>header</code> and <code>logical_screen_descriptor</code>, to learn the basics of using Kaitai.</p>"},{"location":"04_kaitai_basics/#43-types","title":"4.3: Types","text":"<p>The <code>types</code> section is where it becomes vital to reference documentation about the file type you're trying to parse. For example, the <code>gif.ksy</code> file links to the GIF89a Specification.</p> <p>While it takes around 150 lines of code to fully describe the types in <code>gif.ksy</code>, longer descriptions aren't always necessary depending on your project's scope. For instance, if you expect the first 4 bytes to identify an object's width and height, your type could be settled quickly in the main <code>seq</code> section without even having to create a type description:</p> <pre><code>seq:\n  - id: width\n    type: u2\n  - id: height\n    type: u2\n</code></pre> <p>In this example, <code>u2</code> could be replaced with <code>s1</code>, <code>s2</code>, <code>s4</code>, <code>u1</code>, <code>u2</code>, <code>u4</code>, etc., where <code>s</code> or <code>u</code> stands for signed or unsigned bytes, and the number tells the IDE how many bytes to read of that type. However, if you know you'll need to grab a different width and height for some reason, you could instead write this as:</p> <pre><code>seq:\n  - id: dimensions\n    type: width_and_height\n\ntypes:\n  width_and_height:\n    seq:\n      - id: width\n        type: u2\n      - id: height\n        type: u2\n</code></pre> <p>The former method is useful for simple, straightforward data, while the latter is useful for describing repetitive data structures or for reusing types. It allows you to consolidate multiple types into a single place, to repeat types, or to use certain types in the definitions of other types.</p> <p>When looking at <code>gif.ksy</code>'s <code>header</code> type, we see:</p> <pre><code>header:\n  doc-ref: https://www.w3.org/Graphics/GIF/spec-gif89a.txt - section 17\n  seq:\n    - id: magic\n      contents: 'GIF'\n    - id: version\n      type: str\n      size: 3\n      encoding: ASCII\n</code></pre> <p>The keyword <code>magic</code> is especially useful here as a safeguard, acting as a file signature when paired with the <code>contents</code> key. It checks that the first bytes match the contents, \"GIF\" in this case. The <code>magic</code> id is then followed by <code>version</code>, which grabs the next 3 bytes as denoted by <code>size</code> using the built-in <code>str</code> (string) type, and specifies that it is using <code>ASCII</code> encoding.</p> <p>This also highlights one of the bigger strengths of Kaitai: in general, it's pretty straightforward to read and understand. It is also for this reason that, if your project would benefit from having both a Kaitai and a Construct definition, it can be easier to first write your Kaitai description and base the Construct file off of that.</p> <p>This almost-plain-text description strength is also apparent in the next type, <code>logical_screen_descriptor_struct</code>:</p> <pre><code>logical_screen_descriptor_struct:\n  doc-ref: https://www.w3.org/Graphics/GIF/spec-gif89a.txt - section 18\n  seq:\n    - id: screen_width\n      type: u2\n    - id: screen_height\n      type: u2\n    - id: flags\n      type: u1\n    - id: bg_color_index\n      type: u1\n    - id: pixel_aspect_ratio\n      type: u1\n  instances:\n    has_color_table:\n      value: '(flags &amp; 0b10000000) != 0'\n    color_table_size:\n      value: '2 &lt;&lt; (flags &amp; 7)'\n</code></pre> <p>As you can see, it simply grabs the width and the height of the screen on which the GIF will be drawn as 2 unsigned bytes, followed by three unsigned bytes that describe the <code>flags</code>, <code>bg_color_index</code>, and <code>pixel_aspect_ratio</code>. Where it starts to get less straightforward here is in the <code>instances</code> section, which are next up to be explained.</p>"},{"location":"04_kaitai_basics/#431-instances","title":"4.3.1: Instances","text":"<p>After the <code>id</code>s are set in the type <code>seq</code>, we then see the <code>instances</code> section. This section sets new variables by manipulating the previously found <code>flags</code> object using Kaitai's expression language.</p> <p>For example, <code>value: '(flags &amp; 0b10000000) != 0'</code> is doing something called \"bit masking\": taking the bits from the <code>flags</code> byte and showing only the first one. The beginning <code>0b</code> means to read the <code>flags</code> object as pure bytes, then the <code>1</code> means the first bit is allowed through while the rest are masked with <code>0</code>. The value is set as <code>True</code> or <code>False</code> depending on if the first bit is NOT (<code>!=</code>) equal to 0. This expression serves as a boolean operation. Either the GIF does or does not have a color table, and this status is encoded in the first bit of the <code>flags</code> byte.</p> <p>It's worth noting that <code>bytes</code> are not some fundamental unit of computation. The choice to have 8 bits in one byte was a decision made by the International Organization for Standardization (ISO) and the International Electrotechnical Commission (IEC) in 1993, but 6- and 9-bit bytes were common through the 1960s. Bit masking allows you to use every individual bit or combination of bits in a selection to correspond to a different value, surpassing some of the artificially imposed limits on computation. This could come in especially useful if you are attempting to deal with archival data, or if your project would otherwise benefit from non-standard byte-sizing. </p> <p><code>color_table_size</code> is doing a similar operation but with different syntax. <code>7</code> in binary is <code>00000111</code>, so <code>(flags &amp; 7)</code> selects the final 3 bits. <code>2</code> in binary is <code>00000010</code> and <code>&lt;&lt;</code> is the command to \"shift\" bits to the left, so this command shifts \"2\" to the left by <code>(flags &amp; 7)</code> places. This is equivalent to raising 2 to the power of <code>1 + (flags mod 8)</code> and then assigning that new value to a character.</p> <p>In our case, <code>flags = 247</code> (<code>11110111</code> in binary), so <code>has_color_table = True</code>, and <code>1 + (flags mod 8) = 1 + (247 mod 8) = 1 + 7 = 8</code>. Then, \\(2^8 = 256\\), meaning that <code>color_table_size = 256</code>.</p> <p>All of this section has been to explain, in broad strokes, some of the types as shown in the GIF file type. If you're interested in reading more about Kaitai Struct Language, the full documentation can be found here.</p> <p>For now, let's continue this lesson and talk about how this same file type definition can be performed using the Construct library.</p> <p>Continue to Construct basics to learn how to describe file formats programmatically in Python.</p>"},{"location":"05_construct_basics/","title":"5. Construct basics","text":""},{"location":"05_construct_basics/#objectives","title":"Objectives:","text":"<ul> <li>Understand how to begin working with Construct and its basic structure.</li> <li>Explore the Construct description of the GIF file type to see it in action.</li> </ul>"},{"location":"05_construct_basics/#5-defining-the-structure-in-construct","title":"5: Defining the Structure in Construct","text":"<p>Construct is a Python library for declaratively describing and parsing binary data formats. Its functionality is similar to Kaitai Struct, but it uses Python code and programmatic constructs. In Construct, you define <code>Structs</code> (structures) that describe how to interpret sections of a binary file. These <code>Structs</code> can be combined and nested to represent complex file formats, ultimately building up to a main <code>Struct</code> that captures the entire file's structure.</p>"},{"location":"05_construct_basics/#51-struct-basics","title":"5.1: Struct basics","text":"<p>A <code>Struct</code> in Construct is a collection of ordered fields, each with a name and a type. Fields are parsed or built in the order they are defined. When parsing, Construct returns a dictionary-like object with keys matching the field names. Unlike Kaitai, field names are optional in Construct, but naming fields makes the resulting data much easier to work with.</p> <p>Let's recreate the dimensions example from the Kaitai section. Here is how you would define a <code>width_and_height</code> <code>Struct</code> in Construct:</p> <pre><code>width_and_height = Struct(\n    \"width\" / Int16ul,\n    \"height\" / Int16ul\n)\n</code></pre> <p>Here, <code>Int16ul</code> means an Integer of 16 unsigned bits in little-endian format. You can then reuse this <code>width_and_height</code> struct in other structures:</p> <pre><code>dimensions = Struct(\n    \"w_and_h\" / width_and_height\n)\n</code></pre> <p>This modular approach allows you to build up complex file formats from smaller, reusable pieces.</p>"},{"location":"05_construct_basics/#52-building-gifpy","title":"5.2: Building gif.py","text":"<p>Let's look at how Construct can be used to describe the GIF file format, using the gif.py example from Construct's GitHub repository.</p> <p>Unlike Kaitai, where types can be declared in any order, Python requires that each <code>Struct</code> be defined before it is referenced. This means you typically define the smallest components first and then combine them into larger structures. This means that when examining the structure of <code>Structs</code>, it often makes sense to start from the final defined <code>Struct</code> to see what building blocks it uses.</p> <p>Here is the top-level <code>gif_file</code> struct, which represents the entire GIF file:</p> <pre><code>gif_file = Struct(\n    \"signature\" / Const(b\"GIF\"),\n    \"version\" / Const(b\"89a\"),\n    \"logical_screen\" / gif_logical_screen,\n    \"data\" / GreedyRange(gif_data),\n    # \"trailer\" / Const(0x3B, Int8ul)  # Optional: GIF file terminator\n)\n</code></pre> <ul> <li><code>Const(b\"GIF\")</code> and <code>Const(b\"89a\")</code> ensure the file starts with the correct signature and version, similar to the <code>magic</code> keyword in Kaitai. However, this also means it will fail to parse if the version number is anything other than <code>89a</code>.</li> <li><code>logical_screen</code> and <code>data</code> are parsed using other structs defined above <code>gif_file</code>.</li> <li><code>GreedyRange(gif_data)</code> repeats the <code>gif_data</code> struct until the end of the file.</li> </ul> <p>Now, let's look at the <code>gif_logical_screen</code> struct:</p> <pre><code>gif_logical_screen = Struct(\n    \"width\" / Int16ul,\n    \"height\" / Int16ul,\n    \"flags\" / BitStruct(\n        \"global_color_table\" / Bit,\n        \"color_resolution\" / BitsInteger(3),\n        \"sort_flag\" / Bit,\n        \"global_color_table_bpp\" / BitsInteger(3),\n    ),\n    \"bgcolor_index\" / Int8ul,\n    \"pixel_aspect_ratio\" / Int8ul,\n    \"palette\" / If(this.flags.global_color_table,\n        Array(lambda this: 2**(this.flags.global_color_table_bpp + 1),\n            Struct(\n                \"R\" / Int8ul,\n                \"G\" / Int8ul,\n                \"B\" / Int8ul,\n            )\n        )\n    ),\n)\n</code></pre> <ul> <li><code>BitStruct</code> allows you to parse individual bits within a byte, which is useful for fields like <code>flags</code> that pack multiple values into a single byte.</li> <li>The <code>palette</code> field is only present if <code>global_color_table</code> is <code>True</code>. Its length is determined by the value of <code>global_color_table_bpp</code>.</li> </ul> <p>The <code>data</code> section of the GIF file is parsed using a combination of <code>Struct</code>, <code>Switch</code>, and <code>GreedyRange</code>:</p> <pre><code>gif_data = Struct(\n    \"introducer\" / Int8ul,\n    \"data\" / Switch(this.introducer, {\n        0x21: extension,\n        0x2C: image_descriptor,\n    })\n)\n</code></pre> <ul> <li>The <code>introducer</code> byte determines whether the next section is an extension or an image descriptor.</li> <li><code>Switch</code> selects the appropriate struct based on the value of <code>introducer</code>.</li> <li>Each of these sub-structs (<code>extension</code>, <code>image_descriptor</code>) is defined elsewhere in the file.</li> </ul> <p>As mentioned earlier, having <code>GreedyRange(gif_data)</code> in the top-level struct repeats this process for each data block in the file, allowing Construct to parse the entire sequence of GIF blocks.</p> <p>This modular, programmatic approach makes Construct powerful for describing binary formats in Python. While Kaitai uses a declarative YAML-based syntax, Construct leverages Python's syntax and logic, which can be more flexible for complex parsing tasks.</p> <p>Now that you have seen how to describe file formats in both Kaitai and Construct, the next step is to create your own custom data format and try parsing it using these tools. Continue to the next section to learn how to generate and work with example data.</p> <p>Continue to Creating Example Data to generate and save your own binary data.</p>"},{"location":"06_creating_example_data/","title":"6. Creating Example Data","text":""},{"location":"06_creating_example_data/#objectives","title":"Objectives:","text":"<ul> <li>Create example data to practice using Kaitai and Construct.</li> </ul>"},{"location":"06_creating_example_data/#6-creating-example-data","title":"6: Creating Example Data","text":"<p>Now that you understand the basics of file formats and parsing tools, let's put everything together by generating some example data, saving it in a binary file, and preparing to describe its structure with Kaitai and Construct. This hands-on section will help you see how real binary data is created and organized.</p> <p>Suppose we want to simulate a waveform and store it in a binary file. For demonstration, imagine we're measuring vibrations or current intensity. Since we're fabricating data, the context is flexible.</p> <p>We'll use Python for this example, as it's required for Construct. If you haven't set up your Python environment yet, see the setup section (2.2) for instructions.</p>"},{"location":"06_creating_example_data/#61-designing-the-data-structure","title":"6.1: Designing the Data Structure","text":"<p>Let's divide our data into three sections based on intensity: - Full data: The entire waveform. - Mid-range data: Only points where the signal is moderate. - Peak data: Only the most intense points.</p> <p>This could represent three sensors with different sensitivities.</p>"},{"location":"06_creating_example_data/#62-preparing-your-environment","title":"6.2: Preparing Your Environment","text":"<p>You'll need the following Python libraries: - <code>numpy</code> (for numerical arrays) - <code>struct</code> (for binary packing; different from Construct) - <code>matplotlib</code> (optional, for plotting)</p> <p>To check if these are installed, run:</p> <pre><code>pip list\n</code></pre> <p>If you don't see <code>numpy</code> or <code>matplotlib</code>, install them with:</p> <pre><code>pip install numpy\npip install matplotlib\n</code></pre> <p>Note: There is no package called <code>python_struct</code>; <code>struct</code> is part of the Python standard library.</p>"},{"location":"06_creating_example_data/#63-creating-and-visualizing-the-data","title":"6.3: Creating and Visualizing the Data","text":"<p>Create a new <code>.py</code> or <code>.ipynb</code> file (e.g., <code>example_data.py</code>). You can also reference the example notebook.</p> <p>Import the necessary modules:</p> <pre><code>import numpy as np\nimport struct\nimport matplotlib.pyplot as plt\n</code></pre> <p>Now, initialize arrays for each section:</p> <pre><code>full_x, full_y = [], []\nmid_x, mid_y = [], []\npeak_x, peak_y = [], []\n</code></pre> <p>Populate these arrays with simulated data. For example, generate 100,000 points from <code>x = -5</code> to <code>x = 5</code> using the (totally arbitrary) equation \\(y=cos(\\frac{2 \\pi x^2}{x^2 +x})sin(x)\\):</p> <pre><code>for x in np.arange(-5, 5, 0.0001):\n    y = (np.cos((2 * np.pi * x**2)/(x**2 + x))) * np.sin(x)\n    full_x.append(x)\n    full_y.append(y)\n    if y**2 &lt; 0.3:\n        mid_x.append(x)\n        mid_y.append(y)\n    if y**2 &gt; 0.65:\n        peak_x.append(x)\n        peak_y.append(y)\n</code></pre> <p>You can then visualize the data:</p> <pre><code>plt.plot(full_x, full_y)\nplt.title(\"Full Data\")\nplt.show()\n\nplt.plot(mid_x, mid_y)\nplt.title(\"Mid-range Data\")\nplt.show()\n\nplt.scatter(peak_x, peak_y, s=1)\nplt.title(\"Peak Data\")\nplt.show()\n</code></pre> <p>The resulting graphs should look like:</p> <p> </p>"},{"location":"06_creating_example_data/#64-saving-data-as-binary","title":"6.4: Saving Data as Binary","text":"<p>Convert your lists to numpy arrays with a specific data type (e.g., <code>float32</code> for 4 bytes per value):</p> <pre><code>full_x_data = np.array(full_x, dtype=np.float32)\nfull_y_data = np.array(full_y, dtype=np.float32)\nmid_x_data = np.array(mid_x, dtype=np.float32)\nmid_y_data = np.array(mid_y, dtype=np.float32)\npeak_x_data = np.array(peak_x, dtype=np.float32)\npeak_y_data = np.array(peak_y, dtype=np.float32)\n</code></pre> <p>You can experiment with other types like <code>float64</code>, <code>float16</code>, or even integer types if you wish.</p> <p>When saving binary data, it's helpful to include the length of each section at the start of the file or near the front of its respective section. This makes parsing easier later. </p> <pre><code>with open('wave_data.test', 'wb') as f:\n    # Write array lengths as unsigned 4-byte integers\n    f.write(struct.pack('I', len(full_y_data)))\n    f.write(struct.pack('I', len(mid_y_data)))\n    f.write(struct.pack('I', len(peak_y_data)))\n    # Write all arrays in order\n    full_x_data.tofile(f)\n    full_y_data.tofile(f)\n\n    mid_x_data.tofile(f)\n    mid_y_data.tofile(f)\n\n    peak_x_data.tofile(f)\n    peak_y_data.tofile(f)\n</code></pre> <p>You now have a binary file called <code>wave_data.test</code> in your working directory. The file extension is arbitrary; modern systems do not require three-letter extensions.</p> <p>Continue to Kaitai Next Steps to describe and parse your custom data with Kaitai Struct.</p>"},{"location":"07_kaitai_next_steps/","title":"7. Kaitai Next Steps","text":""},{"location":"07_kaitai_next_steps/#objectives","title":"Objectives:","text":"<ul> <li>Describe our fabricated data in the Kaitai IDE.</li> <li>Use the description to parse our custom file format.</li> <li>Return the plots that were created in section 6</li> </ul>"},{"location":"07_kaitai_next_steps/#7-describing-the-data-in-kaitai","title":"7: Describing the Data in Kaitai","text":"<p>Now that you have created a custom binary file, let's describe its structure using Kaitai Struct. This will allow you to parse and analyze your data with generated code.</p> <p>If you don't have the Kaitai Web IDE open, navigate there and create a new <code>.ksy</code> file (e.g., <code>wave_parser.ksy</code>). You can also reference the example file.</p>"},{"location":"07_kaitai_next_steps/#71-writing-the-kaitai-description","title":"7.1: Writing the Kaitai Description","text":""},{"location":"07_kaitai_next_steps/#setting-endianness","title":"Setting Endianness","text":"<p>By default, the binary data you created was written using your operating system's native endianness. If you want to ensure consistency, you can explicitly set the endianness when generating your arrays in Python:</p> <pre><code># For little-endian\nfull_x_data = np.array(full_x, dtype='&lt;float32')  # or '&lt;f4'\n\n# For big-endian\nfull_x_data = np.array(full_x, dtype='&gt;float32')  # or '&gt;f4'\n</code></pre> <p>In your <code>.ksy</code> file, specify the endianness in the <code>meta</code> section:</p> <pre><code>meta:\n  id: test\n  file-extension: test\n  endian: le  # or 'be' for big-endian\n</code></pre>"},{"location":"07_kaitai_next_steps/#describing-the-file-structure","title":"Describing the File Structure","text":"<p>Recall that when saving your binary file, you wrote three unsigned 4-byte integers at the start, representing the lengths of each data section. In Kaitai, you can capture these using <code>u4</code> types:</p> <pre><code>types:\n  full_mid_peak_lens:\n    seq:\n      - id: full_len\n        type: u4\n      - id: mid_len\n        type: u4\n      - id: peak_len\n        type: u4\n</code></pre> <p>In the main <code>seq</code> section, reference this type to read the lengths:</p> <pre><code>seq:\n  - id: lengths\n    type: full_mid_peak_lens\n</code></pre> <p>Next, define the structure for each data section. Since each section contains two arrays (<code>x_data</code> and <code>y_data</code>) of <code>float32</code> values, and you know the length from the header, you can use <code>repeat-expr</code>:</p> <pre><code>  full_data:\n    seq:\n      - id: x_data\n        type: f4\n        repeat: expr\n        repeat-expr: _root.lengths.full_len\n      - id: y_data\n        type: f4\n        repeat: expr\n        repeat-expr: _root.lengths.full_len\n\n  mid_data:\n    seq:\n      - id: x_data\n        type: f4\n        repeat: expr\n        repeat-expr: _root.lengths.mid_len\n      - id: y_data\n        type: f4\n        repeat: expr\n        repeat-expr: _root.lengths.mid_len\n\n  peak_data:\n    seq:\n      - id: x_data\n        type: f4\n        repeat: expr\n        repeat-expr: _root.lengths.peak_len\n      - id: y_data\n        type: f4\n        repeat: expr\n        repeat-expr: _root.lengths.peak_len\n</code></pre> <p>Finally, add these sections to the main <code>seq</code>:</p> <pre><code>  - id: f_data\n    type: full_data\n  - id: m_data\n    type: mid_data\n  - id: p_data\n    type: peak_data\n</code></pre> <p>Your <code>.ksy</code> file should now fully describe the structure of your binary file.</p>"},{"location":"07_kaitai_next_steps/#72-parsing-raw-data-with-a-ksy-file","title":"7.2: Parsing Raw Data with a .ksy File","text":"<p>To parse your data outside the Web IDE, you need to generate code using the Kaitai Struct Compiler (<code>ksc</code>). If you haven't installed it, see the appendix.</p> <p>From your terminal, generate the parser (for Python):</p> <pre><code>ksc -t &lt;language&gt; --outdir &lt;new_foldername&gt; &lt;path/to/your/file.ksy&gt;\n</code></pre> <p>Replacing the parts in the brackets accordingly. For language, the options are: <code>cpp_stl</code>, <code>csharp</code>, <code>java</code>, <code>javascript</code>, <code>perl</code>, <code>php</code>, <code>python</code>, <code>ruby</code>, or <code>all</code>. For this example, we'll be running:</p> <pre><code>ksc -t python --outdir wave_test wave_parser.ksy\n</code></pre> <p>This will create a folder (<code>wave_test</code>) containing a Python file (<code>test.py</code>).</p>"},{"location":"07_kaitai_next_steps/#73-loading-and-using-the-parser-in-python","title":"7.3: Loading and Using the Parser in Python","text":"<p>Make sure your generated parser and your binary data file are in the same directory or update your import paths accordingly.</p> <p>Example usage in Python:</p> <pre><code>from pathlib import Path\nfrom wave_test.test import *  # Replace with the actual class name from your .ksy meta:id\nimport matplotlib.pyplot as plt\n\nraw_data = Path('wave_data.test')\nwave_data = Test.from_file(raw_data)\n\n# Access lengths\nf_length = wave_data.lengths.full_len\nm_length = wave_data.lengths.mid_len\np_length = wave_data.lengths.peak_len\nprint(f_length, m_length, p_length)\n\n# Access and plot full data\nfull_x = wave_data.f_data.x_data\nfull_y = wave_data.f_data.y_data\nplt.plot(full_x, full_y)\nplt.title(\"Full Data\")\nplt.show()\n</code></pre> <p>Repeat for <code>m_data</code> and <code>p_data</code> as needed.</p> <p>You have now described and parsed your custom binary file using Kaitai Struct!  Continue to Construct Next Steps to parse your custom data with the Construct library.</p>"},{"location":"08_construct_next_steps/","title":"8. Construct Next Steps","text":""},{"location":"08_construct_next_steps/#objectives","title":"Objectives:","text":"<ul> <li>Create Structs to describe our example data using the Construct library.</li> <li>Combine our Structs in a final description of our custom file format.</li> <li>Parse our custom file format using our Struct.</li> </ul>"},{"location":"08_construct_next_steps/#8-describing-the-data-in-construct","title":"8: Describing the Data in Construct","text":"<p>Now that you've described your custom binary file in Kaitai, let's do the same using the Construct library in Python. This section will guide you through building Structs to match your file layout, parsing the data, and visualizing the results.</p> <p>If you want to compare with a working example, see the example_struct.ipynb notebook.</p>"},{"location":"08_construct_next_steps/#81-setting-up-and-defining-structs","title":"8.1: Setting Up and Defining Structs","text":"<p>Start by importing the required libraries:</p> <pre><code>from construct import *\nimport matplotlib.pyplot as plt\nimport numpy as np\n</code></pre> <p>Recall that your binary file starts with three 4-byte unsigned integers, giving the lengths of the full, mid, and peak data arrays. We'll define a Struct to capture these:</p> <pre><code>lengths_struct = Struct(\n    \"full_data_len\" / Int32ul,\n    \"mid_data_len\" / Int32ul,\n    \"peak_data_len\" / Int32ul\n)\n</code></pre> <p>Next, define a Struct for the data arrays. Each section contains two arrays (<code>x</code> and <code>y</code>), each of length specified in the header:</p> <pre><code>data_sections = Struct(\n    \"full_x_data\" / Array(this._root.lengths.full_data_len, Float32l),\n    \"full_y_data\" / Array(this._root.lengths.full_data_len, Float32l),\n\n    \"mid_x_data\" / Array(this._root.lengths.mid_data_len, Float32l),\n    \"mid_y_data\" / Array(this._root.lengths.mid_data_len, Float32l),\n\n    \"peak_x_data\" / Array(this._root.lengths.peak_data_len, Float32l),\n    \"peak_y_data\" / Array(this._root.lengths.peak_data_len, Float32l),\n)\n</code></pre> <p>Finally, combine these into the top-level Struct:</p> <pre><code>test_struct = Struct(\n    \"lengths\" / lengths_struct,\n    \"data_sects\" / data_sections\n)\n</code></pre> <p>Tip: You can name your sub-Structs however you like, but be consistent. The quoted names (e.g., <code>\"data_sects\"</code>) are the keys you'll use to access the parsed data.</p>"},{"location":"08_construct_next_steps/#82-parsing-and-visualizing-the-data","title":"8.2: Parsing and Visualizing the Data","text":"<p>Parsing with Construct is straightforward. You can do everything in the same script or notebook:</p> <pre><code>def parse_file(input_path):\n    with open(input_path, 'rb') as input_f:\n        raw_data = input_f.read()\n        parsed_data = test_struct.parse(raw_data)\n\n    # Extract arrays\n    full_x = parsed_data.data_sects.full_x_data\n    full_y = parsed_data.data_sects.full_y_data\n    mid_x = parsed_data.data_sects.mid_x_data\n    mid_y = parsed_data.data_sects.mid_y_data\n    peak_x = parsed_data.data_sects.peak_x_data\n    peak_y = parsed_data.data_sects.peak_y_data\n\n    # Plot full data\n    plt.plot(full_x, full_y)\n    plt.title(\"Full Data\")\n    plt.show()\n\n    # Plot mid-range data\n    plt.plot(mid_x, mid_y)\n    plt.title(\"Mid-range Data\")\n    plt.show()\n\n    # Plot peak data\n    plt.scatter(peak_x, peak_y, s=1)\n    plt.title(\"Peak Data\")\n    plt.show()\n</code></pre> <p>Call your function with the path to your binary file:</p> <pre><code>parse_file(\"wave_data.test\")\n</code></pre> <p>You should see the same plots as when you generated the data, confirming that your Structs correctly describe the file format.</p> <p>You have now parsed your custom binary file using Construct! This approach mirrors the Kaitai description from the previous section, and you can adapt it for more complex formats as needed.</p> <p>Continue to the conclusion for final thoughts and resources.</p>"},{"location":"09_conclusion/","title":"9: Conclusion","text":"<p>Congratulations on completing this lesson on custom binary data formats! You have learned how to:</p> <ul> <li>Understand the difference between file types and file formats.</li> <li>Examine raw binary data and its representation in text editors.</li> <li>Use Kaitai Struct to describe and parse binary file formats in a declarative way.</li> <li>Use the Construct library in Python to programmatically parse and build binary data.</li> <li>Create, save, and visualize your own example binary data.</li> </ul> <p>These skills are foundational for working with scientific, engineering, or custom data formats that are not supported by standard tools. Kaitai and Construct are both powerful and flexible, and can be applied to a wide range of real-world problems.</p> <p>Remember, this lesson only scratches the surface of what you can do with these tools. Both Kaitai and Construct have extensive documentation and active communities:</p> <ul> <li>Kaitai Struct: </li> <li>Official documentation</li> <li>Gitter community chat</li> <li>Construct: </li> <li>Official documentation</li> <li>GitHub repository</li> </ul> <p>If you are working with volumetric or astronomical data, consider joining the yt project's mailing lists for users or developers of the yt Python package: - yt-dev mailing list - yt-users mailing list</p> <p>For further assistance, you can also contact Professor Amy Roberts at the University of Colorado Denver for software and analysis help: amy.roberts@ucdenver.edu</p> <p>For installation help and advanced options, see the Appendix.</p> <p>If you get stuck, remember to consult the official documentation and reach out to the community. Good luck, and happy coding!</p>"},{"location":"10_appendix/","title":"i: Appendix","text":""},{"location":"10_appendix/#kaitai-installation","title":"Kaitai Installation","text":"<p>While the Kaitai Web IDE is sufficient for most users, you may want to install the Kaitai Struct Compiler (<code>ksc</code>) locally if you need to:</p> <ul> <li>Generate parser code for use in your own projects (Python, Java, C#, etc.)</li> <li>Work offline or automate parser generation</li> <li>Use the Kaitai Struct Visualizer (<code>ksv</code>) for console-based visualization</li> </ul> <p>You can download installers for your operating system from the Kaitai Struct download page.</p> <p>After installation, you should have access to:</p> <ul> <li><code>ksc</code> (<code>kaitai-struct-compiler</code>): Command-line tool to compile <code>.ksy</code> files into parsing libraries for your chosen language.</li> <li><code>ksv</code> (<code>kaitai-struct-visualizer</code>, optional): Console-based visualizer for Kaitai Struct files.</li> </ul> <p>For usage instructions, see the official Kaitai documentation.</p>"},{"location":"10_appendix/#additional-construct-installation","title":"Additional Construct Installation","text":"<p>The main Construct library is sufficient for this lesson. However, if you want to install all optional modules (for advanced features or additional protocol support), use:</p> <pre><code>pip install construct[extras]\n</code></pre> <p>For more details, refer to the Construct documentation.</p> <p>If you encounter installation issues, check the official documentation or community forums linked in the conclusion.</p>"}]}